<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>&quot;QuickHaptics micro API Documentation&quot;: Shape Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">"QuickHaptics micro API Documentation"&#160;<span id="projectnumber">1</span></div>
   <div id="projectbrief">QuickHapticsâ„¢ is a micro API that enables any professional with even passing familiarity with C++ to quickly and easily add the kinesthetic feel of what users see and/or hear on a computer screen.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>Shape Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Shape" -->
<p>This is the base class for all primitives.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;Shape.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Shape:</div>
<div class="dyncontent">
<div class="center"><img src="a00160.png" border="0" usemap="#_shape_inherit__map" alt="Inheritance graph"/></div>
<map name="_shape_inherit__map" id="_shape_inherit__map">
<area shape="rect" id="node3" href="a00001.html" title="This class to creates a Box primitive." alt="" coords="5,83,51,112"/><area shape="rect" id="node5" href="a00002.html" title="This class to creates a Cone primitive." alt="" coords="75,83,125,112"/><area shape="rect" id="node7" href="a00004.html" title="This class to loads a Cylinder shape." alt="" coords="149,83,219,112"/><area shape="rect" id="node9" href="a00007.html" title="This class loads a Line shape." alt="" coords="243,83,288,112"/><area shape="rect" id="node11" href="a00008.html" title="This class to loads a Plane shape." alt="" coords="312,83,365,112"/><area shape="rect" id="node13" href="a00013.html" title="This class to loads a Sphere shape." alt="" coords="389,83,451,112"/><area shape="rect" id="node15" href="a00014.html" title="This class is used to display a Text string on screen." alt="" coords="475,83,520,112"/><area shape="rect" id="node17" href="a00015.html" title="This class to loads a triangluar mesh." alt="" coords="544,83,611,112"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Shape:</div>
<div class="dyncontent">
<div class="center"><img src="a00161.png" border="0" usemap="#_shape_coll__map" alt="Collaboration graph"/></div>
<map name="_shape_coll__map" id="_shape_coll__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="a00162.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fcaa6005933a6ef98b87db111b2baa7"></a><!-- doxytag: member="Shape::getHapticVisibility" ref="a7fcaa6005933a6ef98b87db111b2baa7" args="(void)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#a7fcaa6005933a6ef98b87db111b2baa7">getHapticVisibility</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns true or false depending on if the model is haptically visible or not. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab000d757e8bd68570fa3987c20343cfb"></a><!-- doxytag: member="Shape::getGraphicVisibility" ref="ab000d757e8bd68570fa3987c20343cfb" args="(void)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#ab000d757e8bd68570fa3987c20343cfb">getGraphicVisibility</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns true or false depending on if the model is graphically visible or not. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae36bb5e4068544ce93640a9175e187b8"></a><!-- doxytag: member="Shape::getDisplayList" ref="ae36bb5e4068544ce93640a9175e187b8" args="(void)" -->
GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#ae36bb5e4068544ce93640a9175e187b8">getDisplayList</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the unsigned display list index for the shape. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f205675940b4a8cee95c2336f8be146"></a><!-- doxytag: member="Shape::getTexture" ref="a5f205675940b4a8cee95c2336f8be146" args="(void)" -->
glTexture&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#a5f205675940b4a8cee95c2336f8be146">getTexture</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the texture variable associated with the shape. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09907b84ffc46d5c939e4d68979d652b"></a><!-- doxytag: member="Shape::getTextureFilename" ref="a09907b84ffc46d5c939e4d68979d652b" args="(void)" -->
char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#a09907b84ffc46d5c939e4d68979d652b">getTextureFilename</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the filename of the texture file loaded. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abcd3fdc2156a644a40e2cf6968c93e7c"></a><!-- doxytag: member="Shape::getShapeColor" ref="abcd3fdc2156a644a40e2cf6968c93e7c" args="(GLdouble *R, GLdouble *G, GLdouble *B)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#abcd3fdc2156a644a40e2cf6968c93e7c">getShapeColor</a> (GLdouble *R, GLdouble *G, GLdouble *B)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to query the color of the model. Note: The function works if you have previous set the color value of the shape. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae480aa5053243898c6914c59494dc9c4"></a><!-- doxytag: member="Shape::getModelBoundBoxAxes" ref="ae480aa5053243898c6914c59494dc9c4" args="(hduVector3Dd *LongestAxis, hduVector3Dd *MediumAxis, hduVector3Dd *ShortestAxis)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#ae480aa5053243898c6914c59494dc9c4">getModelBoundBoxAxes</a> (hduVector3Dd *LongestAxis, hduVector3Dd *MediumAxis, hduVector3Dd *ShortestAxis)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the boundbox axes (longest, medium, small) in model coordinates. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6c7984da5db8234412e39959e16e72b"></a><!-- doxytag: member="Shape::getShapeAxes" ref="ab6c7984da5db8234412e39959e16e72b" args="(hduVector3Dd *m_UpVector, hduVector3Dd *FrontVector)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#ab6c7984da5db8234412e39959e16e72b">getShapeAxes</a> (hduVector3Dd *m_UpVector, hduVector3Dd *FrontVector)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">User function to read back the user define shape axes set using the function specifyShapeAxes. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">hduMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#af6a74095ec55da44afdbd544cb186d37">getRotation</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">User function to query the shape rotation matrix.  <a href="#af6a74095ec55da44afdbd544cb186d37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">hduVector3Dd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#a9428b5c1fb26a8565cc6e39bbdef4e8c">getTranslation</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">User function to query the shape translation (position)  <a href="#a9428b5c1fb26a8565cc6e39bbdef4e8c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#a23f8ef2220f9ad81fd16e34103467e25">getName</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to return the "name" of the model.  <a href="#a23f8ef2220f9ad81fd16e34103467e25"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#a07a0998236dd8fc18544b634d4d0e601">setHapticVisibility</a> (bool m_HapticallyvisibleFlag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the haptic visibility of a model.  <a href="#a07a0998236dd8fc18544b634d4d0e601"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#afe405ae7ba45f03dc3003f3e07b89879">setGraphicVisibility</a> (bool m_GraphicallyvisibleFlag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This sets the graphic visibility of a model.  <a href="#afe405ae7ba45f03dc3003f3e07b89879"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#ad65a08b1364b893d737e0f63badbd71a">setStiffness</a> (HLdouble ShapeStiffness)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the haptic stiffness of the object (F="k"x + Bv)  <a href="#ad65a08b1364b893d737e0f63badbd71a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#a6f9d359f1dd7cbeb90e32bad10ffb0bd">setStiffness</a> (HLdouble ShapeStiffness, HDstring m_StiffnessSide)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the haptic stiffness of the object (F="k"x + Bv)  <a href="#a6f9d359f1dd7cbeb90e32bad10ffb0bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#ac43a6045838e7b004ac8ffb7def58485">setDamping</a> (HLdouble ShapeDamping)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the haptic damping of the object (F=kx + "B"v)  <a href="#ac43a6045838e7b004ac8ffb7def58485"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#afeed171bb2cb1e366a3e01a215cb74f1">setDamping</a> (HLdouble ShapeDamping, HDstring m_DampingSide)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the haptic damping of the object (F=kx + "B"v)  <a href="#afeed171bb2cb1e366a3e01a215cb74f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#a52f50a41a7e358a64535133e32a64389">setVisible</a> (bool m_HapticallyvisibleFlag, bool m_GraphicallyvisibleFlag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the haptic and graphic visibility of a <a class="el" href="a00012.html" title="This is the base class for all primitives.">Shape</a> in one function.  <a href="#a52f50a41a7e358a64535133e32a64389"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#a612397194065f545644986e2de37ba60">setMagnetic</a> (bool magnetic)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the rendering mode of the object, OpenHaptics terminology: Constraint or Contact rendering<br/>
 TRUE - Magnetic<br/>
 FALSE - Normal<br/>
.  <a href="#a612397194065f545644986e2de37ba60"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#ad9e9b5217f255c55ebec942ffbcdb1ee">setMagnetic</a> (bool magnetic, HLfloat SnapDistance)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the rendering mode of the object. Specify the snap distance. OpenHaptics terminology: Constraint or Contact rendering TRUE - Magnetic<br/>
 FALSE - Normal<br/>
.  <a href="#ad9e9b5217f255c55ebec942ffbcdb1ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9f67fdb59581aac509f8674834a25f7"></a><!-- doxytag: member="Shape::setContact" ref="ae9f67fdb59581aac509f8674834a25f7" args="(bool contact)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#ae9f67fdb59581aac509f8674834a25f7">setContact</a> (bool contact)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the rendering mode of the object, (Constraint or Contact) TRUE - Normal<br/>
 FALSE - Magnetic. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#a730f2899c99312baacbc94318940c994">setFriction</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets default static friction values on the surface of a shape.  <a href="#a730f2899c99312baacbc94318940c994"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#af3b4938cd6e569f548a80c02d85b259d">setFriction</a> (HLfloat m_StaticFriction, HLfloat m_DynamicFriction)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets specific friction values for a shape.  <a href="#af3b4938cd6e569f548a80c02d85b259d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#a1ec802ceb40fdc013f7290d2e6309175">setFriction</a> (HLfloat m_StaticFriction, HLfloat m_DynamicFriction, HDstring m_FrictionSide)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets specific friction values for a shape.  <a href="#a1ec802ceb40fdc013f7290d2e6309175"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#ae48939334619953e6d1ced2a3ff15d62">setPopthrough</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the default popthrough value.  <a href="#ae48939334619953e6d1ced2a3ff15d62"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#a73e0c81b7b4ddf814687c9ba2ce09386">setPopthrough</a> (HLdouble m_popthroughForce)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded function for user specified popthrough value.  <a href="#a73e0c81b7b4ddf814687c9ba2ce09386"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#a6b191272f86fa9cde0c9756d276d6569">setPopthrough</a> (HLdouble m_popthroughForce, HDstring m_popthroughSide)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded function for user specified popthrough value and popthrough side.  <a href="#a6b191272f86fa9cde0c9756d276d6569"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#a80ecc062e0474f795725e63b8a504758">setTouchableFace</a> (HDstring FrontOrBack)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to set which face of the shape is touchable, The default is the front face.  <a href="#a80ecc062e0474f795725e63b8a504758"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#a579387ec731a3a534b2223a4adb4d7d8">setName</a> (char *IncomingName)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a name for the shape.  <a href="#a579387ec731a3a534b2223a4adb4d7d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#ae5c216f70f390e3335caf742ad638bc4">setTexture</a> (HDstring Filename)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to load and bind a graphics texture file to a shape.  <a href="#ae5c216f70f390e3335caf742ad638bc4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#a9fc643294c3727f95d06f8b7daaf9145">setSpin</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to make the model spin in it's place.  <a href="#a9fc643294c3727f95d06f8b7daaf9145"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#aa557eef00fcded0d268ce23173ddc49b">setSpin</a> (HLenum Direction, float m_Velocity, hduVector3Dd m_RotationAxis)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to make the model spin in it's place, with axis, direction and rotation velocity specified.  <a href="#aa557eef00fcded0d268ce23173ddc49b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#aca181984ff88e9d4049008137b430864">setSpin</a> (float m_Velocity, hduVector3Dd m_RotationAxis)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to make the model spin in it's place, with axis, direction and rotation velocity specified.  <a href="#aca181984ff88e9d4049008137b430864"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#a6d4686175d7f606ed6a9932e6bf2a6e3">setDraggable</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make the object draggable.  <a href="#a6d4686175d7f606ed6a9932e6bf2a6e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#af2d3726812f777572ce83d632e732b6d">setUnDraggable</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make the object undraggable or static.  <a href="#af2d3726812f777572ce83d632e732b6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#a1ca57d630074ad2e20fbfe04aa0f1635">setOrbit</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Function to cause the shape to revolve around the origin.  <a href="#a1ca57d630074ad2e20fbfe04aa0f1635"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#a3a70dfe573e4922ead4aa174bd9325ee">setOrbit</a> (HLenum Direction, float m_Velocity, hduVector3Dd m_RevolutionAxis, hduVector3Dd m_RevolutionPoint)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to cause the shape to revolve around a user specified point,axis with specified direction and velocity.  <a href="#a3a70dfe573e4922ead4aa174bd9325ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#a8dae76b4c538d0e344ea7e83e152e491">setOrbit</a> (float m_Velocity, hduVector3Dd m_RevolutionAxis, hduVector3Dd m_RevolutionPoint)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to cause the shape to revolve around a user specified point,axis with specified direction and velocity.  <a href="#a8dae76b4c538d0e344ea7e83e152e491"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#ad6a64caa823b9d3d0018a48afadc8146">setTransform</a> (hduMatrix ModelTransformMatrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">User function to set the model tranform explicitly.  <a href="#ad6a64caa823b9d3d0018a48afadc8146"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#a90f8cc07d47e5be8b124a58da1b26661">setTranslation</a> (hduVector3Dd Translation)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to set a translation to the shape.  <a href="#a90f8cc07d47e5be8b124a58da1b26661"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#a80080be054fb74ce4efa41479246963c">setTranslation</a> (HLdouble x, HLdouble y, HLdouble z)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to set a translation to the shape.  <a href="#a80080be054fb74ce4efa41479246963c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#a14b63730207216c60b653ed245593451">setRotation</a> (hduVector3Dd Axis, HLdouble Angle)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to set the rotation of the model about the origin explicitly.  <a href="#a14b63730207216c60b653ed245593451"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#a44e1a81e92d8c6120f523b46ad134bc3">setRotationInPlace</a> (hduVector3Dd Axis, HLdouble Angle)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to set the rotation of the model about it's current position explicitly.  <a href="#a44e1a81e92d8c6120f523b46ad134bc3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#aada585ed80bc660e05e39dbc677c4315">setScale</a> (GLdouble scale)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to scale the shape in it's current position.  <a href="#aada585ed80bc660e05e39dbc677c4315"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#ad5445b3965c4e6df92c1ee0ddd93fe12">setScaleInPlace</a> (GLdouble scale)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to scale the shape.  <a href="#ad5445b3965c4e6df92c1ee0ddd93fe12"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#a9d5f8d9d8850fe7f3e480efbd779230e">specifyShapeAxes</a> (GLfloat UpX, GLfloat UpY, GLfloat UpZ, GLfloat FrontX, GLfloat FrontY, GLfloat FrontZ)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaab95a5fc3266cee8a91c63de7467f6c"></a><!-- doxytag: member="Shape::setFrameRateDependent" ref="aaab95a5fc3266cee8a91c63de7467f6c" args="(void)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#aaab95a5fc3266cee8a91c63de7467f6c">setFrameRateDependent</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function makes all "spins" and "orbits" frame rate dependent. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afed3fd929427e65aef892f2d54328df9"></a><!-- doxytag: member="Shape::setFrameRateIndependent" ref="afed3fd929427e65aef892f2d54328df9" args="(void)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#afed3fd929427e65aef892f2d54328df9">setFrameRateIndependent</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function makes all "spins" and "orbits" frame rate independent. The default is independent (may cause troublesome haptic rendering on large meshes) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08bae7cb8a0480902e6367c873d58d86"></a><!-- doxytag: member="Shape::setShapeToDefault" ref="a08bae7cb8a0480902e6367c873d58d86" args="(void)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#a08bae7cb8a0480902e6367c873d58d86">setShapeToDefault</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function restores the ModelTransform matrix to it's original default value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19c1d9611e02b8366d106b85a694c3ab"></a><!-- doxytag: member="Shape::setShapeColor" ref="a19c1d9611e02b8366d106b85a694c3ab" args="(GLdouble m_R, GLdouble m_G, GLdouble m_B)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#a19c1d9611e02b8366d106b85a694c3ab">setShapeColor</a> (GLdouble m_R, GLdouble m_G, GLdouble m_B)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function colors the shape with a user defined color. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17fbba71eb6ba3f5d56ccba2c4fd0d6a"></a><!-- doxytag: member="Shape::setRenderModeFeedback" ref="a17fbba71eb6ba3f5d56ccba2c4fd0d6a" args="(void)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#a17fbba71eb6ba3f5d56ccba2c4fd0d6a">setRenderModeFeedback</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the render mode for the haptic rendering for the shape as Feedback buffer. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#a3a38c403dffc9b51851a4a7325924904">setRenderModeDepth</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the render mode for the haptic rendering for the shape as Depth buffer.  <a href="#a3a38c403dffc9b51851a4a7325924904"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#aecdf664b17a59e69bfbf8680c1f310a6">setSceneDraggable</a> (bool SceneDraggableFlag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the all the shapes declared after calling this function as draggable or undraggable.  <a href="#aecdf664b17a59e69bfbf8680c1f310a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad70a9ef927b857fde807061ddbd1377d"></a><!-- doxytag: member="Shape::setGlobalRenderModeFeedback" ref="ad70a9ef927b857fde807061ddbd1377d" args="(void)" -->
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#ad70a9ef927b857fde807061ddbd1377d">setGlobalRenderModeFeedback</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the render mode for all objects declared after a call to this function to the feedback buffer. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#a5f42ba64613d07b097f92c9e16348472">setMipMapTextureSmooth</a> (bool SmoothTexFlag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will sets the mipmap render mode for textures.  <a href="#a5f42ba64613d07b097f92c9e16348472"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fbfadf7d4959eb0bcd00a990b127d46"></a><!-- doxytag: member="Shape::QHRenderer" ref="a7fbfadf7d4959eb0bcd00a990b127d46" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#a7fbfadf7d4959eb0bcd00a990b127d46">QHRenderer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27f9146bec966f43e2e62516bf454a11"></a><!-- doxytag: member="Shape::TriMesh" ref="a27f9146bec966f43e2e62516bf454a11" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#a27f9146bec966f43e2e62516bf454a11">TriMesh</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9591eb6f6543f40292912e27b74f4d27"></a><!-- doxytag: member="Shape::Cursor" ref="a9591eb6f6543f40292912e27b74f4d27" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#a9591eb6f6543f40292912e27b74f4d27">Cursor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5fb4f1ba76ae58af1fc3651817d1fe0e"></a><!-- doxytag: member="Shape::DeviceSpace" ref="a5fb4f1ba76ae58af1fc3651817d1fe0e" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#a5fb4f1ba76ae58af1fc3651817d1fe0e">DeviceSpace</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f229d41a6747c1fd12cbe102d06b13c"></a><!-- doxytag: member="Shape::Box" ref="a3f229d41a6747c1fd12cbe102d06b13c" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#a3f229d41a6747c1fd12cbe102d06b13c">Box</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03209e24ad2bf104e4a8d1daa63d38e3"></a><!-- doxytag: member="Shape::Cone" ref="a03209e24ad2bf104e4a8d1daa63d38e3" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#a03209e24ad2bf104e4a8d1daa63d38e3">Cone</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af10773c43b75882cad4b616a1592e455"></a><!-- doxytag: member="Shape::Cylinder" ref="af10773c43b75882cad4b616a1592e455" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#af10773c43b75882cad4b616a1592e455">Cylinder</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a864cca3466d5710a4742ec5caf34b497"></a><!-- doxytag: member="Shape::Line" ref="a864cca3466d5710a4742ec5caf34b497" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#a864cca3466d5710a4742ec5caf34b497">Line</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89c71bac3ec153ca700e1cd69900b6ce"></a><!-- doxytag: member="Shape::Plane" ref="a89c71bac3ec153ca700e1cd69900b6ce" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#a89c71bac3ec153ca700e1cd69900b6ce">Plane</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fb393709fbab6670acba42a2f0757b7"></a><!-- doxytag: member="Shape::Sphere" ref="a6fb393709fbab6670acba42a2f0757b7" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#a6fb393709fbab6670acba42a2f0757b7">Sphere</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee0ad1dafe471596e6d25530d9fbaf0c"></a><!-- doxytag: member="Shape::Text" ref="aee0ad1dafe471596e6d25530d9fbaf0c" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#aee0ad1dafe471596e6d25530d9fbaf0c">Text</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This is the base class for all primitives. </p>
<p>This class contains all basic parameters required for a primitive like it's transforms, rotation and translation functions. Inaddition to this it contains several properties like the stiffness, damping friction etc..of the virtual object. It also controls the dragging function. i.e defines if a shape can be dragged and contains functions to allow for dragging a shape. </p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a23f8ef2220f9ad81fd16e34103467e25"></a><!-- doxytag: member="Shape::getName" ref="a23f8ef2220f9ad81fd16e34103467e25" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* Shape::getName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function to return the "name" of the model. </p>
<p>The name of the mode is set using the setName function. The default name for any model is the name of the class of the primitive </p>

</div>
</div>
<a class="anchor" id="af6a74095ec55da44afdbd544cb186d37"></a><!-- doxytag: member="Shape::getRotation" ref="af6a74095ec55da44afdbd544cb186d37" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hduMatrix Shape::getRotation </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>User function to query the shape rotation matrix. </p>
<p>This function is a subset of the getTransform function . It returns the rotation matrix with out the translation components. </p>

</div>
</div>
<a class="anchor" id="a9428b5c1fb26a8565cc6e39bbdef4e8c"></a><!-- doxytag: member="Shape::getTranslation" ref="a9428b5c1fb26a8565cc6e39bbdef4e8c" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hduVector3Dd Shape::getTranslation </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>User function to query the shape translation (position) </p>
<p>This function returns the position of the shape as a vector of 3 doubles (hduVector3Dd) </p>

</div>
</div>
<a class="anchor" id="ac43a6045838e7b004ac8ffb7def58485"></a><!-- doxytag: member="Shape::setDamping" ref="ac43a6045838e7b004ac8ffb7def58485" args="(HLdouble ShapeDamping)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Shape::setDamping </td>
          <td>(</td>
          <td class="paramtype">HLdouble&#160;</td>
          <td class="paramname"><em>ShapeDamping</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the haptic damping of the object (F=kx + "B"v) </p>
<p>The values for damping are normalized from 0 to 1. With 1 representing the maximum damping that can be stably rendered by the haptic device in use<br/>
 By default the damping will be applied on both the front and back surfaces of the shape </p>

</div>
</div>
<a class="anchor" id="afeed171bb2cb1e366a3e01a215cb74f1"></a><!-- doxytag: member="Shape::setDamping" ref="afeed171bb2cb1e366a3e01a215cb74f1" args="(HLdouble ShapeDamping, HDstring m_DampingSide)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Shape::setDamping </td>
          <td>(</td>
          <td class="paramtype">HLdouble&#160;</td>
          <td class="paramname"><em>ShapeDamping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HDstring&#160;</td>
          <td class="paramname"><em>m_DampingSide</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the haptic damping of the object (F=kx + "B"v) </p>
<p>The values for damping are normalized from 0 to 1. With 1 representing the maximum damping that can be stably rendered by the haptic device in use. <br/>
 The programmer can also specify which side of the shape the damping will apply to.<br/>
 Acceptable strings are "front" and "back" (case insensitive). In case of an improper match both sides of the stiffness will be applied on both sides of the shape </p>

</div>
</div>
<a class="anchor" id="a6d4686175d7f606ed6a9932e6bf2a6e3"></a><!-- doxytag: member="Shape::setDraggable" ref="a6d4686175d7f606ed6a9932e6bf2a6e3" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Shape::setDraggable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function to make the object draggable. </p>
<p>This function sets the object as draggable by the cursor. Note: By default all objects in the scene are draggable. Use this function to to dynamically change an object to draggable in a callback or any other scenario </p>

</div>
</div>
<a class="anchor" id="a730f2899c99312baacbc94318940c994"></a><!-- doxytag: member="Shape::setFriction" ref="a730f2899c99312baacbc94318940c994" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Shape::setFriction </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets default static friction values on the surface of a shape. </p>
<p>Static Friction Coefficient = 0.5<br/>
 Dynamic Friction Coefficient = 0.5<br/>
</p>
<p>Here 0.5 represents the half maximum range of the haptic device in use. </p>

</div>
</div>
<a class="anchor" id="af3b4938cd6e569f548a80c02d85b259d"></a><!-- doxytag: member="Shape::setFriction" ref="af3b4938cd6e569f548a80c02d85b259d" args="(HLfloat m_StaticFriction, HLfloat m_DynamicFriction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Shape::setFriction </td>
          <td>(</td>
          <td class="paramtype">HLfloat&#160;</td>
          <td class="paramname"><em>m_StaticFriction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HLfloat&#160;</td>
          <td class="paramname"><em>m_DynamicFriction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets specific friction values for a shape. </p>
<p>This function lets the programmer define friction values for a shape. However OpenHaptics by default applied the friction property on both sides of the surface. 0 &lt;= m_StaticFriction &lt;= 1<br/>
 0 &lt;= m_DynamicFriction &lt;= 1<br/>
 </p>

</div>
</div>
<a class="anchor" id="a1ec802ceb40fdc013f7290d2e6309175"></a><!-- doxytag: member="Shape::setFriction" ref="a1ec802ceb40fdc013f7290d2e6309175" args="(HLfloat m_StaticFriction, HLfloat m_DynamicFriction, HDstring m_FrictionSide)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Shape::setFriction </td>
          <td>(</td>
          <td class="paramtype">HLfloat&#160;</td>
          <td class="paramname"><em>m_StaticFriction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HLfloat&#160;</td>
          <td class="paramname"><em>m_DynamicFriction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HDstring&#160;</td>
          <td class="paramname"><em>m_FrictionSide</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets specific friction values for a shape. </p>
<p>The functions lets the programmer set all friction paremeters for a shape. Including the side.</p>
<p>0 &lt;= m_StaticFriction &lt;= 1<br/>
 0 &lt;= m_DynamicFriction &lt;= 1<br/>
</p>
<p>m_FrictionSide = "front" or "back" (case insensitive) </p>

</div>
</div>
<a class="anchor" id="afe405ae7ba45f03dc3003f3e07b89879"></a><!-- doxytag: member="Shape::setGraphicVisibility" ref="afe405ae7ba45f03dc3003f3e07b89879" args="(bool m_GraphicallyvisibleFlag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Shape::setGraphicVisibility </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>m_GraphicallyvisibleFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This sets the graphic visibility of a model. </p>
<p>TRUE - Visible<br/>
 FALSE - Invisible </p>

</div>
</div>
<a class="anchor" id="a07a0998236dd8fc18544b634d4d0e601"></a><!-- doxytag: member="Shape::setHapticVisibility" ref="a07a0998236dd8fc18544b634d4d0e601" args="(bool m_HapticallyvisibleFlag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Shape::setHapticVisibility </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>m_HapticallyvisibleFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function sets the haptic visibility of a model. </p>
<p>TRUE - Visible<br/>
 FALSE - Invisible </p>

</div>
</div>
<a class="anchor" id="a612397194065f545644986e2de37ba60"></a><!-- doxytag: member="Shape::setMagnetic" ref="a612397194065f545644986e2de37ba60" args="(bool magnetic)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Shape::setMagnetic </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>magnetic</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the rendering mode of the object, OpenHaptics terminology: Constraint or Contact rendering<br/>
 TRUE - Magnetic<br/>
 FALSE - Normal<br/>
. </p>
<p>In addition to the normal mode of rendering a shape. This is an additional mode, which allows the programmer to set the shape as "magnetic". Turning this property on makes the shape feel sticky. Use this feature in simulations to create a sticky line for guiding a surgical tool. </p>

</div>
</div>
<a class="anchor" id="ad9e9b5217f255c55ebec942ffbcdb1ee"></a><!-- doxytag: member="Shape::setMagnetic" ref="ad9e9b5217f255c55ebec942ffbcdb1ee" args="(bool magnetic, HLfloat SnapDistance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Shape::setMagnetic </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>magnetic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HLfloat&#160;</td>
          <td class="paramname"><em>SnapDistance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the rendering mode of the object. Specify the snap distance. OpenHaptics terminology: Constraint or Contact rendering TRUE - Magnetic<br/>
 FALSE - Normal<br/>
. </p>
<p>In addition to the normal mode of rendering a shape. This is an additional mode, which allows the programmer to set the shape as "magnetic". Turning this property on maked the shape feel sticky. Use this feature in simulations to create a sticky line for guiding a surgical tool.<br/>
 In addition to turning the shape magnetic, this over loaded function lets the programmer specify how close to the object the proxy must approach before it gets 'stuck' to the shape.<br/>
 Note: The SnapDistance MUST be smaller than the OpenGl workspace. Otherwise openhaptics will throw a BoundBox error. </p>

</div>
</div>
<a class="anchor" id="a5f42ba64613d07b097f92c9e16348472"></a><!-- doxytag: member="Shape::setMipMapTextureSmooth" ref="a5f42ba64613d07b097f92c9e16348472" args="(bool SmoothTexFlag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Shape::setMipMapTextureSmooth </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>SmoothTexFlag</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function will sets the mipmap render mode for textures. </p>
<p>If a true value is passed:<br/>
 GL_TEX_MAG_FILTER to GL_LINEAR (default mode)<br/>
 GL_TEX_MIN_FILTER to GL_LINEAR_MIPMAP_LINEAR (default mode)<br/>
<br/>
</p>
<p>If a false values is passed:<br/>
 GL_TEX_MAG_FILTER to GL_LINEAR<br/>
 GL_TEX_MIN_FILTER to GL_LINEAR<br/>
<br/>
 Note: This is a static function and hence a call to this function will change the texture mode for ALL textures, loaded AFTER a call to this function </p>

</div>
</div>
<a class="anchor" id="a579387ec731a3a534b2223a4adb4d7d8"></a><!-- doxytag: member="Shape::setName" ref="a579387ec731a3a534b2223a4adb4d7d8" args="(char *IncomingName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Shape::setName </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>IncomingName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a name for the shape. </p>
<p>This function allows the programmer to set a name for a shape. This function is usefult when the user want to reference the shape in another function or a callback function. In this case the "search" (Trimesh::searchTrimesh, <a class="el" href="a00013.html#a4f900deedca2f2e6dff3447e28adb867" title="This function is used to search for a Sphere by a name and return a pointer to the Sphere Object if f...">Sphere::searchSphere</a> etc...) functions can be used to return search the shapes and return a pointer to the programmer" </p>

</div>
</div>
<a class="anchor" id="a1ca57d630074ad2e20fbfe04aa0f1635"></a><!-- doxytag: member="Shape::setOrbit" ref="a1ca57d630074ad2e20fbfe04aa0f1635" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Shape::setOrbit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default Function to cause the shape to revolve around the origin. </p>
<p>This function causes the shape to move in a circular path around the origin. The default axis is the Y axis and the shape orbits with a default angular velocity of 9 degrees per second. </p>

</div>
</div>
<a class="anchor" id="a3a70dfe573e4922ead4aa174bd9325ee"></a><!-- doxytag: member="Shape::setOrbit" ref="a3a70dfe573e4922ead4aa174bd9325ee" args="(HLenum Direction, float m_Velocity, hduVector3Dd m_RevolutionAxis, hduVector3Dd m_RevolutionPoint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Shape::setOrbit </td>
          <td>(</td>
          <td class="paramtype">HLenum&#160;</td>
          <td class="paramname"><em>Direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m_Velocity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hduVector3Dd&#160;</td>
          <td class="paramname"><em>m_RevolutionAxis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hduVector3Dd&#160;</td>
          <td class="paramname"><em>m_RevolutionPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function to cause the shape to revolve around a user specified point,axis with specified direction and velocity. </p>
<p>This is the detailed orbit function with:<br/>
</p>
<p>Direction: HL_CW or HL_CCW<br/>
 0 &lt;= m_Velocity &lt;= 1.0 here 1.0 corresponds to 180 degrees per second<br/>
 m_RevolutionAxis - Any axis<br/>
 m_RevolutionPoint - Any point </p>

</div>
</div>
<a class="anchor" id="a8dae76b4c538d0e344ea7e83e152e491"></a><!-- doxytag: member="Shape::setOrbit" ref="a8dae76b4c538d0e344ea7e83e152e491" args="(float m_Velocity, hduVector3Dd m_RevolutionAxis, hduVector3Dd m_RevolutionPoint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Shape::setOrbit </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m_Velocity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hduVector3Dd&#160;</td>
          <td class="paramname"><em>m_RevolutionAxis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hduVector3Dd&#160;</td>
          <td class="paramname"><em>m_RevolutionPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function to cause the shape to revolve around a user specified point,axis with specified direction and velocity. </p>
<p>This is the detailed orbit function with:<br/>
</p>
<p>-1.0 &lt;= m_Velocity &lt;= 1.0 here 1.0 corresponds to 180 degrees per second<br/>
 m_RevolutionAxis - Any axis<br/>
 m_RevolutionPoint - Any point </p>

</div>
</div>
<a class="anchor" id="ae48939334619953e6d1ced2a3ff15d62"></a><!-- doxytag: member="Shape::setPopthrough" ref="ae48939334619953e6d1ced2a3ff15d62" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Shape::setPopthrough </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the default popthrough value. </p>
<p>This function allows the programmer to set a popthrough value for a shape. A "popthrough" occurs when the programmer exerts above a particular threshold on a shape. This causes the proxy to fall through the surface creating a "popthrough".</p>
<p>Default threshold = 0.5<br/>
 Here 0.5 indicated the normalised force value.<br/>
 1.0 being the max continuous force of the device.<br/>
 The popthrough effect is applied on both the front and back surface of the shape.<br/>
 Note: The <a class="el" href="a00012.html#a80ecc062e0474f795725e63b8a504758" title="Function to set which face of the shape is touchable, The default is the front face.">Shape::setTouchableFace</a> function has to be used to make the backface touchable </p>

</div>
</div>
<a class="anchor" id="a73e0c81b7b4ddf814687c9ba2ce09386"></a><!-- doxytag: member="Shape::setPopthrough" ref="a73e0c81b7b4ddf814687c9ba2ce09386" args="(HLdouble m_popthroughForce)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Shape::setPopthrough </td>
          <td>(</td>
          <td class="paramtype">HLdouble&#160;</td>
          <td class="paramname"><em>m_popthroughForce</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloaded function for user specified popthrough value. </p>
<p>This function allows the programmer to set a popthrough value for a shape. A "popthrough" occurs when the user exerts above a particular threshold on a shape. This causes the porxy to fall through the surface creating a "popthrough".</p>
<p>0.0 &lt;= m_popthroughForce &lt;= 1.0<br/>
 1.0 being the max continuous force of the device.<br/>
 The popthrough effect is applied on both the front and back surface of the shape.<br/>
 Note: The <a class="el" href="a00012.html#a80ecc062e0474f795725e63b8a504758" title="Function to set which face of the shape is touchable, The default is the front face.">Shape::setTouchableFace</a> function has to be used to make the backface touchable </p>

</div>
</div>
<a class="anchor" id="a6b191272f86fa9cde0c9756d276d6569"></a><!-- doxytag: member="Shape::setPopthrough" ref="a6b191272f86fa9cde0c9756d276d6569" args="(HLdouble m_popthroughForce, HDstring m_popthroughSide)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Shape::setPopthrough </td>
          <td>(</td>
          <td class="paramtype">HLdouble&#160;</td>
          <td class="paramname"><em>m_popthroughForce</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HDstring&#160;</td>
          <td class="paramname"><em>m_popthroughSide</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloaded function for user specified popthrough value and popthrough side. </p>
<p>This function allows the programmer to set a popthrough value for a shape. A "popthrough" occurs when the user exerts above a particular threshold on a shape. This causes the porxy to fall through the surface creating a "popthrough". In addition this overloaded version of the setPopthrough function allows the programmer to specify which face "front" or "back" will have the popthrough property.</p>
<p>0.0 &lt;= m_popthroughForce &lt;= 1.0<br/>
 1.0 being the max continuous force of the device.<br/>
 m_popthroughSide = "front" or "back" (case insensitive) </p>

</div>
</div>
<a class="anchor" id="a3a38c403dffc9b51851a4a7325924904"></a><!-- doxytag: member="Shape::setRenderModeDepth" ref="a3a38c403dffc9b51851a4a7325924904" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Shape::setRenderModeDepth </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function sets the render mode for the haptic rendering for the shape as Depth buffer. </p>
<p>The depth buffer rendering, though more efficient than the feedback buffer sometimes causes a confusion in correctly identifying the shape IDs. The symptoms of this behavior are: While attempting to drag one object, one or more other objects are picked up. </p>

</div>
</div>
<a class="anchor" id="a14b63730207216c60b653ed245593451"></a><!-- doxytag: member="Shape::setRotation" ref="a14b63730207216c60b653ed245593451" args="(hduVector3Dd Axis, HLdouble Angle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Shape::setRotation </td>
          <td>(</td>
          <td class="paramtype">hduVector3Dd&#160;</td>
          <td class="paramname"><em>Axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HLdouble&#160;</td>
          <td class="paramname"><em>Angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function to set the rotation of the model about the origin explicitly. </p>
<p>This function allows the programmer to specify a one time rotation of the model about an axis. The rotation is centered about the origin </p>

</div>
</div>
<a class="anchor" id="a44e1a81e92d8c6120f523b46ad134bc3"></a><!-- doxytag: member="Shape::setRotationInPlace" ref="a44e1a81e92d8c6120f523b46ad134bc3" args="(hduVector3Dd Axis, HLdouble Angle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Shape::setRotationInPlace </td>
          <td>(</td>
          <td class="paramtype">hduVector3Dd&#160;</td>
          <td class="paramname"><em>Axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HLdouble&#160;</td>
          <td class="paramname"><em>Angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function to set the rotation of the model about it's current position explicitly. </p>
<p>This function allows the programmer to specify a one time rotation of the model about an axis. The model is rotated about it's current position </p>

</div>
</div>
<a class="anchor" id="aada585ed80bc660e05e39dbc677c4315"></a><!-- doxytag: member="Shape::setScale" ref="aada585ed80bc660e05e39dbc677c4315" args="(GLdouble scale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Shape::setScale </td>
          <td>(</td>
          <td class="paramtype">GLdouble&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function to scale the shape in it's current position. </p>
<p>This function scales the model according to the scale input by the programmer. Note: Scaling the model this way may cause it to move away from the original position. For scaling in place use the setScaleInPlace function </p>

</div>
</div>
<a class="anchor" id="ad5445b3965c4e6df92c1ee0ddd93fe12"></a><!-- doxytag: member="Shape::setScaleInPlace" ref="ad5445b3965c4e6df92c1ee0ddd93fe12" args="(GLdouble scale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Shape::setScaleInPlace </td>
          <td>(</td>
          <td class="paramtype">GLdouble&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function to scale the shape. </p>
<p>This function scales the model in it's current position (ie no translation) according to the scale input by the programmer. </p>

</div>
</div>
<a class="anchor" id="aecdf664b17a59e69bfbf8680c1f310a6"></a><!-- doxytag: member="Shape::setSceneDraggable" ref="aecdf664b17a59e69bfbf8680c1f310a6" args="(bool SceneDraggableFlag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Shape::setSceneDraggable </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>SceneDraggableFlag</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function sets the all the shapes declared after calling this function as draggable or undraggable. </p>
<p>Use this static function to declare all shapes in the scene declared after a call to this function as draggable or undraggable based on the status of the SceneDraggableFlag. To make all the shapes in the scene undraggable declare setSceneDraggable(false) before declaring any shapes.</p>
<p>Note: This function cannot be used in any of the callbacks to make the scene undraggable </p>

</div>
</div>
<a class="anchor" id="aca181984ff88e9d4049008137b430864"></a><!-- doxytag: member="Shape::setSpin" ref="aca181984ff88e9d4049008137b430864" args="(float m_Velocity, hduVector3Dd m_RotationAxis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Shape::setSpin </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m_Velocity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hduVector3Dd&#160;</td>
          <td class="paramname"><em>m_RotationAxis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function is used to make the model spin in it's place, with axis, direction and rotation velocity specified. </p>
<p>The set sping function updates the shape transform every frame to spin the model.The rotation of the model is frame rate independent unless explicitly set to be frame rate dependent by setFrameRateDependent function.<br/>
 -1.0 &lt;= m_Velocity &lt;= 1.0 (1.0 corresponds to 180 degrees per second) </p>

</div>
</div>
<a class="anchor" id="a9fc643294c3727f95d06f8b7daaf9145"></a><!-- doxytag: member="Shape::setSpin" ref="a9fc643294c3727f95d06f8b7daaf9145" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Shape::setSpin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function is used to make the model spin in it's place. </p>
<p>The set sping function updates the shape transform every frame to spin the model. By default the model spins on the Y axis at a rate of 9 degrees per second in the clockwise direction. The rotation of the model is frame rate independent unless explicitly set to be frame rate dependednt by setFrameRateDependent function. </p>

</div>
</div>
<a class="anchor" id="aa557eef00fcded0d268ce23173ddc49b"></a><!-- doxytag: member="Shape::setSpin" ref="aa557eef00fcded0d268ce23173ddc49b" args="(HLenum Direction, float m_Velocity, hduVector3Dd m_RotationAxis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Shape::setSpin </td>
          <td>(</td>
          <td class="paramtype">HLenum&#160;</td>
          <td class="paramname"><em>Direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m_Velocity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hduVector3Dd&#160;</td>
          <td class="paramname"><em>m_RotationAxis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function is used to make the model spin in it's place, with axis, direction and rotation velocity specified. </p>
<p>The set sping function updates the shape transform every frame to spin the model.The rotation of the model is frame rate independent unless explicitly set to be frame rate dependent by setFrameRateDependent function.<br/>
 Direction = HL_CW (Clockwise) or HL_CCW (Counterclockwise)<br/>
 0 &lt;= m_Velocity &lt;= 1.0 (1.0 corresponds to 180 degrees per second) </p>

</div>
</div>
<a class="anchor" id="ad65a08b1364b893d737e0f63badbd71a"></a><!-- doxytag: member="Shape::setStiffness" ref="ad65a08b1364b893d737e0f63badbd71a" args="(HLdouble ShapeStiffness)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Shape::setStiffness </td>
          <td>(</td>
          <td class="paramtype">HLdouble&#160;</td>
          <td class="paramname"><em>ShapeStiffness</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the haptic stiffness of the object (F="k"x + Bv) </p>
<p>The values for stiffness are normalized from 0 to 1. With 1 representing the maximum stiffness that can be stably rendered by the haptic device in use<br/>
 By default the stiffness will be applied on both the front and back surfaces of the shape </p>

</div>
</div>
<a class="anchor" id="a6f9d359f1dd7cbeb90e32bad10ffb0bd"></a><!-- doxytag: member="Shape::setStiffness" ref="a6f9d359f1dd7cbeb90e32bad10ffb0bd" args="(HLdouble ShapeStiffness, HDstring m_StiffnessSide)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Shape::setStiffness </td>
          <td>(</td>
          <td class="paramtype">HLdouble&#160;</td>
          <td class="paramname"><em>ShapeStiffness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HDstring&#160;</td>
          <td class="paramname"><em>m_StiffnessSide</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the haptic stiffness of the object (F="k"x + Bv) </p>
<p>The values for stiffness are normalized from 0 to 1. With 1 representing the maximum stiffness that can be stably rendered by the haptic device in use. <br/>
 The programmer can also specify which side of the shape the stiffness will apply to.<br/>
 Acceptable strings are "front" and "back" (case insensitive). In case of an improper match both sides of the stiffness will be applied on both sides of the shape </p>

</div>
</div>
<a class="anchor" id="ae5c216f70f390e3335caf742ad638bc4"></a><!-- doxytag: member="Shape::setTexture" ref="ae5c216f70f390e3335caf742ad638bc4" args="(HDstring Filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Shape::setTexture </td>
          <td>(</td>
          <td class="paramtype">HDstring&#160;</td>
          <td class="paramname"><em>Filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function to load and bind a graphics texture file to a shape. </p>
<p>This function is used to load texture files from disk. Specify the path and file name using forward slashes eg. foodir/foo.jpg. The function supports many popular file formats: JPG, bmp, tga, gif and more </p>

</div>
</div>
<a class="anchor" id="a80ecc062e0474f795725e63b8a504758"></a><!-- doxytag: member="Shape::setTouchableFace" ref="a80ecc062e0474f795725e63b8a504758" args="(HDstring FrontOrBack)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Shape::setTouchableFace </td>
          <td>(</td>
          <td class="paramtype">HDstring&#160;</td>
          <td class="paramname"><em>FrontOrBack</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function to set which face of the shape is touchable, The default is the front face. </p>
<p>FrontOrback = "front", "back" , anything else =&gt; "frontandback" </p>

</div>
</div>
<a class="anchor" id="ad6a64caa823b9d3d0018a48afadc8146"></a><!-- doxytag: member="Shape::setTransform" ref="ad6a64caa823b9d3d0018a48afadc8146" args="(hduMatrix ModelTransformMatrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Shape::setTransform </td>
          <td>(</td>
          <td class="paramtype">hduMatrix&#160;</td>
          <td class="paramname"><em>ModelTransformMatrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>User function to set the model tranform explicitly. </p>
<p>This is an advanced function that let the programmer set the transform for the shape manually. The matrix has to be of type "hduMatrix" </p>

</div>
</div>
<a class="anchor" id="a80080be054fb74ce4efa41479246963c"></a><!-- doxytag: member="Shape::setTranslation" ref="a80080be054fb74ce4efa41479246963c" args="(HLdouble x, HLdouble y, HLdouble z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Shape::setTranslation </td>
          <td>(</td>
          <td class="paramtype">HLdouble&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HLdouble&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HLdouble&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function to set a translation to the shape. </p>
<p>This is a function that allows the programmer to explicitly specify the relative change in position of the shape in OpenGL worldspace. </p>

</div>
</div>
<a class="anchor" id="a90f8cc07d47e5be8b124a58da1b26661"></a><!-- doxytag: member="Shape::setTranslation" ref="a90f8cc07d47e5be8b124a58da1b26661" args="(hduVector3Dd Translation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Shape::setTranslation </td>
          <td>(</td>
          <td class="paramtype">hduVector3Dd&#160;</td>
          <td class="paramname"><em>Translation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function to set a translation to the shape. </p>
<p>This is a function that allows the programmer to explicitly specify the relative change in position of the shape in OpenGL worldspace. </p>

</div>
</div>
<a class="anchor" id="af2d3726812f777572ce83d632e732b6d"></a><!-- doxytag: member="Shape::setUnDraggable" ref="af2d3726812f777572ce83d632e732b6d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Shape::setUnDraggable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function to make the object undraggable or static. </p>
<p>This function sets the object as NOT draggable by the cursor. Note: By default all objects in the scene are draggable. Use this function to to dynamically change an object to non-draggable in a callback or any other scenario. </p>

</div>
</div>
<a class="anchor" id="a52f50a41a7e358a64535133e32a64389"></a><!-- doxytag: member="Shape::setVisible" ref="a52f50a41a7e358a64535133e32a64389" args="(bool m_HapticallyvisibleFlag, bool m_GraphicallyvisibleFlag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Shape::setVisible </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>m_HapticallyvisibleFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>m_GraphicallyvisibleFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function sets the haptic and graphic visibility of a <a class="el" href="a00012.html" title="This is the base class for all primitives.">Shape</a> in one function. </p>
<p>By default all shapes are haptically and graphically visible </p>

</div>
</div>
<a class="anchor" id="a9d5f8d9d8850fe7f3e480efbd779230e"></a><!-- doxytag: member="Shape::specifyShapeAxes" ref="a9d5f8d9d8850fe7f3e480efbd779230e" args="(GLfloat UpX, GLfloat UpY, GLfloat UpZ, GLfloat FrontX, GLfloat FrontY, GLfloat FrontZ)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Shape::specifyShapeAxes </td>
          <td>(</td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>UpX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>UpY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>UpZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>FrontX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>FrontY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>FrontZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function to orient the shape according to auser defined coordinate system in modelspace</p>
<p>This function allows the user to change the orientation of the model by specifying a new coordinate system for the shape. For example: The programmer can transform the native xyz axes in model coordinates to be aligned along a new set of specified xyz axes defined by this function. In doing so the programmer can make cange the orientation of the model. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Perforce/uAPI/uAPI V1/header/Shape.h</li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Nov 16 2011 17:27:42 for "QuickHaptics micro API Documentation" by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
