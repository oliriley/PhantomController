<HTML>
<HEAD>
<TITLE>Public Members for gstTriPolyMesh</TITLE>
<!-- BBSOO Generated by Object Outline 2.1d, Bumble Bee Software April 29, 2002 -->
<LINK REL=STYLESHEET HREF="main.css">
</HEAD>

<BODY  TOPMARGIN=0>

<SPAN>
<TABLE WIDTH="100%" CELLPADDING=5 BGCOLOR=black CELLSPACING=0>
<TR ALIGN=LEFT><TD class="HEADER">
    <A HREF="GHOST_c_gstTriPolyMesh_c.html#c_gstTriPolyMesh" STYLE="background: black;color: white;text-decoration: none;">Overview For gstTriPolyMesh</A>
    <IMG BORDER=0 SRC="sep.gif"><A HREF="GHOST_c_gstTriPolyMesh_c.html#ud43525029c_gstTriPolyMesh_classtoc" STYLE="background : black;color: white;text-decoration: none;">Members</A>
    <IMG BORDER=0 SRC="sep.gif"><A HREF="GHOST_I___GHOST_Library_7__Polygon_Mesh_ch.html#chp_GHOST_SDK_Reference_Manual_I___GHOST_Library_7__Polygon_Mesh" STYLE="background: black;color: white;text-decoration: none;">Chapter </A>
</TD></TR></TABLE>
</SPAN>



<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_gstTriPolyMesh"></A>gstTriPolyMesh</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR> <B>gstTriPolyMesh</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) ;</TD></TR>
</TABLE>

<P>Creates an initially empty set of triangular polygons.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_gstTriPolyMesh_const_gstTriPolyMeshRef"></A>gstTriPolyMesh</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR> <B>gstTriPolyMesh</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>const <A HREF="GHOST_c_gstTriPolyMesh_c.html#c_gstTriPolyMesh">gstTriPolyMesh</A>&amp; mesh  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Copy Constructor.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_gstTriPolyMesh_int_double_vertices_______3___int_int_trianglePolygons_______3___int"></A>gstTriPolyMesh</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR> <B>gstTriPolyMesh</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>int numVertices  ,</NOBR> <NOBR>double vertices [ ] [ 3 ]   ,</NOBR> <NOBR>int numTrianglePolygons  ,</NOBR> <NOBR>int trianglePolygons [ ] [ 3 ]   ,</NOBR> <NOBR>gstBoolean useSpatialPartition  = TRUE </NOBR> ) ;</TD></TR>
</TABLE>

<P>Constructor. Backward compatible with old gstPolyMesh.


<DL>

  <DT><B>numVertices</B>
  <DD>The number of vertices.

  <DT><B></B>
  <DD>The vertices.

  <DT><B>numTrianglePolygons</B>
  <DD>The number of triangles.

  <DT><B></B>
  <DD>The triangles.

  <DT><B>useSpatialPartition</B>
  <DD>


</DL>




<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_gstTriPolyMesh_int_int_doublePtr_int_int_intPtr_int"></A>gstTriPolyMesh</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR> <B>gstTriPolyMesh</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>int numVertices  ,</NOBR> <NOBR>int v_dimension  ,</NOBR> <NOBR>double* vertices  ,</NOBR> <NOBR>int numTrianglePolygons  ,</NOBR> <NOBR>int num_sides  ,</NOBR> <NOBR>int* trianglePolygons  ,</NOBR> <NOBR>gstBoolean useSpatialPartition  = TRUE </NOBR> ) ;</TD></TR>
</TABLE>

<P>Constructor.


<DL>

  <DT><B>numVertices</B>
  <DD>The number of vertices.

  <DT><B>v_dimension</B>
  <DD>Dimension of vertices == 3.

  <DT><B>vertices</B>
  <DD>The vertices.

  <DT><B>numTrianglePolygons</B>
  <DD>The number of triangles.

  <DT><B>num_sides</B>
  <DD>Number of sides of polys == 3.

  <DT><B>trianglePolygons</B>
  <DD>The triangles.

  <DT><B>useSpatialPartition</B>
  <DD>


</DL>




<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_gstTriPolyMesh_int_int_doublePtrPtr_int_int_intPtrPtr_int"></A>gstTriPolyMesh</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR> <B>gstTriPolyMesh</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>int numVertices  ,</NOBR> <NOBR>int v_dimension  ,</NOBR> <NOBR>double** vertices  ,</NOBR> <NOBR>int numTrianglePolygons  ,</NOBR> <NOBR>int num_sides  ,</NOBR> <NOBR>int** trianglePolygons  ,</NOBR> <NOBR>gstBoolean useSpatialPartition  = TRUE </NOBR> ) ;</TD></TR>
</TABLE>

<P>Constructor. Backward compatible with old gstPolyMesh.


<DL>

  <DT><B>numVertices</B>
  <DD>The number of vertices.

  <DT><B>v_dimension</B>
  <DD>Dimension of vertices == 3.

  <DT><B>vertices</B>
  <DD>The vertices.

  <DT><B>numTrianglePolygons</B>
  <DD>The number of triangles.

  <DT><B>num_sides</B>
  <DD>Number of sides of polys == 3.

  <DT><B>trianglePolygons</B>
  <DD>The triangles.

  <DT><B>useSpatialPartition</B>
  <DD>


</DL>




<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh__gstTriPolyMesh"></A>~gstTriPolyMesh</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>virtual <B>~gstTriPolyMesh</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) ;</TD></TR>
</TABLE>

<P>






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_beginModify_gstSpatialObjectPtr"></A>beginModify</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>virtual gstBoolean <B>beginModify</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR><A HREF="GHOST_c_gstSpatialObject_c.html#c_gstSpatialObject">gstSpatialObject</A>* so  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Signifies that this object may be modified after this call.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_clone_const"></A>clone</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>virtual <A HREF="GHOST_c_gstSpatialObject_c.html#c_gstSpatialObject">gstSpatialObject</A>* <B>clone</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) const;</TD></TR>
</TABLE>

<P>Virtual method to copy this object and return base class pointer to newly copied object. Allows copy of object to be made using base class pointer.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_cloneTriPolyMesh_const"></A>cloneTriPolyMesh</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR><A HREF="GHOST_c_gstTriPolyMesh_c.html#c_gstTriPolyMesh">gstTriPolyMesh</A>* <B>cloneTriPolyMesh</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) const;</TD></TR>
</TABLE>

<P>Virtual method to copy this <A HREF="GHOST_c_gstTriPolyMesh_c.html#c_gstTriPolyMesh">gstTriPolyMesh</A> object and return <A HREF="GHOST_c_gstTriPolyMesh_c.html#c_gstTriPolyMesh">gstTriPolyMesh</A> pointer to newly cloned object.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_copyPolygon_const_gstTriPolyPtr"></A>copyPolygon</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR><A HREF="GHOST_c_gstTriPoly_c.html#c_gstTriPoly">gstTriPoly</A>* <B>copyPolygon</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>const <A HREF="GHOST_c_gstTriPoly_c.html#c_gstTriPoly">gstTriPoly</A>* poly  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Create new <A HREF="GHOST_c_gstTriPoly_c.html#c_gstTriPoly">gstTriPoly</A> by copying poly's vertices first and then creating poly with copied vertices. A pointer to the newly created polygon is returned.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_copyVertex_gstVertexPtr"></A>copyVertex</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR><A HREF="GHOST_c_gstVertex_c.html#c_gstVertex">gstVertex</A>* <B>copyVertex</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR><A HREF="GHOST_c_gstVertex_c.html#c_gstVertex">gstVertex</A>* vertToCopy  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Creates new <A HREF="GHOST_c_gstVertex_c.html#c_gstVertex">gstVertex</A> with same position as vertToCopy if a vertex at that position does not already exist. Also copies the key if the key is not already used by a vertex of this <A HREF="GHOST_c_gstTriPolyMesh_c.html#c_gstTriPolyMesh">gstTriPolyMesh</A>. A pointer to the already existing coincident vertex or the newly created vertex is returned.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_createTriPoly_const_int_const_int_const_int_const_int"></A>createTriPoly</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR><A HREF="GHOST_c_gstTriPoly_c.html#c_gstTriPoly">gstTriPoly</A>* <B>createTriPoly</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>const gstVertexKey v1key  ,</NOBR> <NOBR>const gstVertexKey v2key  ,</NOBR> <NOBR>const gstVertexKey v3key  ,</NOBR> <NOBR>const gstPolyKey polyKey  = INT_MAX </NOBR> ) ;</TD></TR>
</TABLE>

<P>Creates new <A HREF="GHOST_c_gstTriPoly_c.html#c_gstTriPoly">gstTriPoly</A> with vertices v1, v2, and v3 and gives the new polygon a key of polyKey. A pointer to the newly created polygon is returned if successful. If v1, v2, and v3 not valid and unique keys to polygons of this <A HREF="GHOST_c_gstTriPolyMesh_c.html#c_gstTriPolyMesh">gstTriPolyMesh</A>, then NULL is returned. If polyKey is not unique, then a new unique key is generated and assigned to the new polygon.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_createTriPoly_gstVertexPtr_gstVertexPtr_gstVertexPtr_int"></A>createTriPoly</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR><A HREF="GHOST_c_gstTriPoly_c.html#c_gstTriPoly">gstTriPoly</A>* <B>createTriPoly</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR><A HREF="GHOST_c_gstVertex_c.html#c_gstVertex">gstVertex</A>* v1  ,</NOBR> <NOBR><A HREF="GHOST_c_gstVertex_c.html#c_gstVertex">gstVertex</A>* v2  ,</NOBR> <NOBR><A HREF="GHOST_c_gstVertex_c.html#c_gstVertex">gstVertex</A>* v3  ,</NOBR> <NOBR>gstPolyKey polyKey  = INT_MAX </NOBR> ) ;</TD></TR>
</TABLE>

<P>Creates new <A HREF="GHOST_c_gstTriPoly_c.html#c_gstTriPoly">gstTriPoly</A> with vertices v1, v2, and v3 and gives the new polygon a key of polyKey. A pointer to the newly created polygon is returned if successful. If v1, v2, and v3 are not unique then NULL is returned. If polyKey is not unique, then a new unique key is generated and assigned to the new polygon.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_createVertex_const_gstPoint_const_int"></A>createVertex</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR><A HREF="GHOST_c_gstVertex_c.html#c_gstVertex">gstVertex</A>* <B>createVertex</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>const <A HREF="GHOST_c_gstPoint_c.html#c_gstPoint">gstPoint</A> vertPos  ,</NOBR> <NOBR>const gstVertexKey vertKey  = INT_MAX </NOBR> ) ;</TD></TR>
</TABLE>

<P>Create new <A HREF="GHOST_c_gstVertex_c.html#c_gstVertex">gstVertex</A> to be used in gstTriPolys that follow. New <A HREF="GHOST_c_gstVertex_c.html#c_gstVertex">gstVertex</A> is positioned at vertPos and is indexed by vertkey. If vertKey is not unique, then a unique key and generated and used. A pointer to the newly created <A HREF="GHOST_c_gstVertex_c.html#c_gstVertex">gstVertex</A> is returned if successful. Otherwise, NULL is returned.<P CLASS=OOCMT>Note: Does not check for existing vertices of same position or key.</P>







<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_endModify_gstSpatialObjectPtr"></A>endModify</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>virtual gstBoolean <B>endModify</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR><A HREF="GHOST_c_gstSpatialObject_c.html#c_gstSpatialObject">gstSpatialObject</A>* so  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Signifies that modifications to the argument spatial object have ceased. It is assumed that the spatial object is a part of this triangular polygon mesh.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_findCoincidentVertex_const_gstVertexPtr"></A>findCoincidentVertex</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR><A HREF="GHOST_c_gstVertex_c.html#c_gstVertex">gstVertex</A>* <B>findCoincidentVertex</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>const <A HREF="GHOST_c_gstVertex_c.html#c_gstVertex">gstVertex</A>* vert  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Returns pointer to <A HREF="GHOST_c_gstVertex_c.html#c_gstVertex">gstVertex</A> coincident with vert if one exists. Otherwise, NULL is returned.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_getBoundingBox"></A>getBoundingBox</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>virtual <A HREF="GHOST_c_gstBoundingBox_c.html#c_gstBoundingBox">gstBoundingBox</A> <B>getBoundingBox</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) ;</TD></TR>
</TABLE>

<P>Returns <A HREF="GHOST_c_gstBoundingBox_c.html#c_gstBoundingBox">gstBoundingBox</A> just enclosing this triangle.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_getBoundingSphere"></A>getBoundingSphere</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>virtual <A HREF="GHOST_c_gstBoundingSphere_c.html#c_gstBoundingSphere">gstBoundingSphere</A> <B>getBoundingSphere</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) ;</TD></TR>
</TABLE>

<P>Returns <A HREF="GHOST_c_gstBoundingSphere_c.html#c_gstBoundingSphere">gstBoundingSphere</A> just enclosing this triangle.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_getContainedObjects_vectorLTgstSpatialObjectPtrGTRef"></A>getContainedObjects</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>virtual gstBoolean <B>getContainedObjects</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>gstSpatialObjectPtrVector&amp; v  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Returned vector of pointers to gstSpatialObjects that are contained within this <A HREF="GHOST_c_gstTriPolyMesh_c.html#c_gstTriPolyMesh">gstTriPolyMesh</A>.<P CLASS=OOCMT>Note: This operation takes proportional time and memory to number of contained objects.</P>







<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_getDeleteStrandedVertices_const"></A>getDeleteStrandedVertices</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>gstBoolean <B>getDeleteStrandedVertices</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) const;</TD></TR>
</TABLE>

<P>Returns TRUE if vertices that have no neighbor edges are to be deleted. Otherwise, FALSE is returned.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_getNumPolygons_const"></A>getNumPolygons</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>int <B>getNumPolygons</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) const;</TD></TR>
</TABLE>

<P>Returns number of polygons defined for <A HREF="GHOST_c_gstTriPolyMesh_c.html#c_gstTriPolyMesh">gstTriPolyMesh</A>.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_getNumVertices_const"></A>getNumVertices</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>int <B>getNumVertices</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) const;</TD></TR>
</TABLE>

<P>Returns number of vertices defined for <A HREF="GHOST_c_gstTriPolyMesh_c.html#c_gstTriPolyMesh">gstTriPolyMesh</A>. This includes vertices that are stranded (have no neighbor polygons) that have not been deleted.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_getPolygon_const_int_const"></A>getPolygon</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR><A HREF="GHOST_c_gstTriPoly_c.html#c_gstTriPoly">gstTriPoly</A>* <B>getPolygon</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>const gstPolyKey polyKey  </NOBR> ) const;</TD></TR>
</TABLE>

<P>Returns pointer to gstTriPolygon that has key equal to polyKey if one exists. Otherwise, NULL is returned.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_getSpatialPartition"></A>getSpatialPartition</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR><A HREF="GHOST_c_gstSpatialPartition_c.html#c_gstSpatialPartition">gstSpatialPartition</A>* <B>getSpatialPartition</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) ;</TD></TR>
</TABLE>

<P>Returns pointer to <A HREF="GHOST_c_gstSpatialPartition_c.html#c_gstSpatialPartition">gstSpatialPartition</A> defined for this object if one has been created. Otherwise, NULL is returned.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_getTypeId_const"></A>getTypeId</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>virtual gstType <B>getTypeId</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) const;</TD></TR>
</TABLE>

<P>Virtual form of <A HREF="GHOST_c_gstTriPolyMeshcpup.html#f_gstTriPolyMesh_getClassTypeId">getClassTypeId</A>.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_getVertex_const_int_const"></A>getVertex</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR><A HREF="GHOST_c_gstVertex_c.html#c_gstVertex">gstVertex</A>* <B>getVertex</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>const gstVertexKey vertKey  </NOBR> ) const;</TD></TR>
</TABLE>

<P>Returns pointer to <A HREF="GHOST_c_gstVertex_c.html#c_gstVertex">gstVertex</A> that has key equal to vertKey if one exists. Otherwise, NULL is returned.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_initSpatialPartition"></A>initSpatialPartition</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>void <B>initSpatialPartition</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) ;</TD></TR>
</TABLE>

<P>Creates a new spatial partition for this object if one hasn't already been defined and initializes it to reflect the mesh defined by this <A HREF="GHOST_c_gstTriPolyMesh_c.html#c_gstTriPolyMesh">gstTriPolyMesh</A>.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_intersectFirstInOut_LS_P_const_gstLineSegmentRef_gstLineIntersectionInfoFirst_ParamRef"></A>intersectFirstInOut_LS_P</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>virtual <A HREF="GHOST_c_gstLineIntersectionInfo_c.html#c_gstLineIntersectionInfo">gstLineIntersectionInfo</A>::IntersectionType <B>intersectFirstInOut_LS_P</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>const <A HREF="GHOST_c_gstLineSegment_c.html#c_gstLineSegment">gstLineSegment</A>&amp; lineSegment  ,</NOBR> <NOBR><A HREF="GHOST_c_gstLineIntersectionInfoFirst_Param_c.html#c_gstLineIntersectionInfoFirst_Param">gstLineIntersectionInfoFirst_Param</A>&amp; intersectionInfo  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Intersects <A HREF="GHOST_c_gstLineSegment_c.html#c_gstLineSegment">gstLineSegment</A> with spatial object and returns gstIntersection::intersectionType which can be; in, out, inOut, none_inside, or none_outside. 'in' specifies an intersection into the object, 'out' specifies an intersection leaving the object, 'inOut' specifies intersections entering and leaving the object, 'none_insdie' specifies that the object is not intersected and the line segment is within the object, and 'none_outside' specifies that there is no intersection and the line segment is outside of the object.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_intersectFirstInOut_LS_PSO_const_gstLineSegmentRef_gstLineIntersectionInfoFirst_ParamSpatObjRef"></A>intersectFirstInOut_LS_PSO</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>virtual <A HREF="GHOST_c_gstLineIntersectionInfo_c.html#c_gstLineIntersectionInfo">gstLineIntersectionInfo</A>::IntersectionType <B>intersectFirstInOut_LS_PSO</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>const <A HREF="GHOST_c_gstLineSegment_c.html#c_gstLineSegment">gstLineSegment</A>&amp; lineSegment  ,</NOBR> <NOBR><A HREF="GHOST_c_gstLineIntersectionInfoFirst_ParamSpatObj_c.html#c_gstLineIntersectionInfoFirst_ParamSpatObj">gstLineIntersectionInfoFirst_ParamSpatObj</A>&amp; intersectionInfo  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Intersects <A HREF="GHOST_c_gstLineSegment_c.html#c_gstLineSegment">gstLineSegment</A> with spatial object and returns gstIntersection::intersectionType which can be; in, out, inOut, none_inside, or none_outside. 'in' specifies an intersection into the object, 'out' specifies an intersection leaving the object, 'inOut' specifies intersections entering and leaving the object, 'none_insdie' specifies that the object is not intersected and the line segment is within the object, and 'none_outside' specifies that there is no intersection and the line segment is outside of the object.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_intersectFirstIn_LS_P_const_gstLineSegmentRef_gstLineIntersectionInfoFirst_ParamRef"></A>intersectFirstIn_LS_P</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>virtual <A HREF="GHOST_c_gstLineIntersectionInfo_c.html#c_gstLineIntersectionInfo">gstLineIntersectionInfo</A>::IntersectionType <B>intersectFirstIn_LS_P</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>const <A HREF="GHOST_c_gstLineSegment_c.html#c_gstLineSegment">gstLineSegment</A>&amp; lineSegment  ,</NOBR> <NOBR><A HREF="GHOST_c_gstLineIntersectionInfoFirst_Param_c.html#c_gstLineIntersectionInfoFirst_Param">gstLineIntersectionInfoFirst_Param</A>&amp; intersectionInfo  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Intersects <A HREF="GHOST_c_gstLineSegment_c.html#c_gstLineSegment">gstLineSegment</A> with spatial object and returns gstIntersection::intersectionType which can be; in, out, inOut, none_inside, or none_outside. 'in' specifies an intersection into the object, 'out' specifies an intersection leaving the object, 'inOut' specifies intersections entering and leaving the object, 'none_insdie' specifies that the object is not intersected and the line segment is within the object, and 'none_outside' specifies that there is no intersection and the line segment is outside of the object.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_intersectFirstIn_LS_PSO_const_gstLineSegmentRef_gstLineIntersectionInfoFirst_ParamSpatObjRef"></A>intersectFirstIn_LS_PSO</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>virtual <A HREF="GHOST_c_gstLineIntersectionInfo_c.html#c_gstLineIntersectionInfo">gstLineIntersectionInfo</A>::IntersectionType <B>intersectFirstIn_LS_PSO</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>const <A HREF="GHOST_c_gstLineSegment_c.html#c_gstLineSegment">gstLineSegment</A>&amp; lineSegment  ,</NOBR> <NOBR><A HREF="GHOST_c_gstLineIntersectionInfoFirst_ParamSpatObj_c.html#c_gstLineIntersectionInfoFirst_ParamSpatObj">gstLineIntersectionInfoFirst_ParamSpatObj</A>&amp; intersectionInfo  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Intersects <A HREF="GHOST_c_gstLineSegment_c.html#c_gstLineSegment">gstLineSegment</A> with spatial object and returns gstIntersection::intersectionType which can be; in, out, inOut, none_inside, or none_outside. 'in' specifies an intersection into the object, 'out' specifies an intersection leaving the object, 'inOut' specifies intersections entering and leaving the object, 'none_insdie' specifies that the object is not intersected and the line segment is within the object, and 'none_outside' specifies that there is no intersection and the line segment is outside of the object.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_intersectFirstOut_LS_P_const_gstLineSegmentRef_gstLineIntersectionInfoFirst_ParamRef"></A>intersectFirstOut_LS_P</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>virtual <A HREF="GHOST_c_gstLineIntersectionInfo_c.html#c_gstLineIntersectionInfo">gstLineIntersectionInfo</A>::IntersectionType <B>intersectFirstOut_LS_P</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>const <A HREF="GHOST_c_gstLineSegment_c.html#c_gstLineSegment">gstLineSegment</A>&amp; lineSegment  ,</NOBR> <NOBR><A HREF="GHOST_c_gstLineIntersectionInfoFirst_Param_c.html#c_gstLineIntersectionInfoFirst_Param">gstLineIntersectionInfoFirst_Param</A>&amp; intersectionInfo  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Intersects <A HREF="GHOST_c_gstLineSegment_c.html#c_gstLineSegment">gstLineSegment</A> with spatial object and returns gstIntersection::intersectionType which can be; in, out, inOut, none_inside, or none_outside. 'in' specifies an intersection into the object, 'out' specifies an intersection leaving the object, 'inOut' specifies intersections entering and leaving the object, 'none_insdie' specifies that the object is not intersected and the line segment is within the object, and 'none_outside' specifies that there is no intersection and the line segment is outside of the object.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_intersectFirstOut_LS_PSO_const_gstLineSegmentRef_gstLineIntersectionInfoFirst_ParamSpatObjRef"></A>intersectFirstOut_LS_PSO</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>virtual <A HREF="GHOST_c_gstLineIntersectionInfo_c.html#c_gstLineIntersectionInfo">gstLineIntersectionInfo</A>::IntersectionType <B>intersectFirstOut_LS_PSO</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>const <A HREF="GHOST_c_gstLineSegment_c.html#c_gstLineSegment">gstLineSegment</A>&amp; lineSegment  ,</NOBR> <NOBR><A HREF="GHOST_c_gstLineIntersectionInfoFirst_ParamSpatObj_c.html#c_gstLineIntersectionInfoFirst_ParamSpatObj">gstLineIntersectionInfoFirst_ParamSpatObj</A>&amp; intersectionInfo  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Intersects <A HREF="GHOST_c_gstLineSegment_c.html#c_gstLineSegment">gstLineSegment</A> with spatial object and returns gstIntersection::intersectionType which can be; in, out, inOut, none_inside, or none_outside. 'in' specifies an intersection into the object, 'out' specifies an intersection leaving the object, 'inOut' specifies intersections entering and leaving the object, 'none_insdie' specifies that the object is not intersected and the line segment is within the object, and 'none_outside' specifies that there is no intersection and the line segment is outside of the object.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_intersect_BC_const_gstBoundingCubeRef"></A>intersect_BC</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>virtual <A HREF="GHOST_c_gstObjectIntersectionInfo_c.html#c_gstObjectIntersectionInfo">gstObjectIntersectionInfo</A>::IntersectionType <B>intersect_BC</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>const <A HREF="GHOST_c_gstBoundingCube_c.html#c_gstBoundingCube">gstBoundingCube</A>&amp; cube  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Not implemented yet.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_intersect_BS_SOSet_const_gstBoundingSphereRef_gstObjectIntersectionInfo_SpatialObjectPtrSetRef"></A>intersect_BS_SOSet</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>virtual <A HREF="GHOST_c_gstObjectIntersectionInfo_c.html#c_gstObjectIntersectionInfo">gstObjectIntersectionInfo</A>::IntersectionType <B>intersect_BS_SOSet</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>const <A HREF="GHOST_c_gstBoundingSphere_c.html#c_gstBoundingSphere">gstBoundingSphere</A>&amp; sphere  ,</NOBR> <NOBR>gstObjectIntersectionInfo_SpatialObjectPtrSet&amp; intersectionInfo  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Intersects gstSimpleCube with spatial object and returns gstIntersection::intersectionType which can be; enclosed, enclosing, overlapping, or none. 'enclosed' specifies that the simple cube is enclosed within the object, 'enclosing' specifies that the simple cube encloses the spatial object, 'overlapping' specifies that the simple cube and the spatial object overlap eachother, and 'none' specifies that the simple cube and spatial object occupy separate space.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_intersect_Ray_P_const_gstRayRef_gstLineIntersectionInfoFirst_ParamRef"></A>intersect_Ray_P</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>virtual <A HREF="GHOST_c_gstLineIntersectionInfo_c.html#c_gstLineIntersectionInfo">gstLineIntersectionInfo</A>::IntersectionType <B>intersect_Ray_P</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>const <A HREF="GHOST_c_gstRay_c.html#c_gstRay">gstRay</A>&amp; ray  ,</NOBR> <NOBR><A HREF="GHOST_c_gstLineIntersectionInfoFirst_Param_c.html#c_gstLineIntersectionInfoFirst_Param">gstLineIntersectionInfoFirst_Param</A>&amp; intersectionInfo  </NOBR> ) ;</TD></TR>
</TABLE>

<P>






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_isOfType_int_const"></A>isOfType</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>virtual gstBoolean <B>isOfType</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>gstType type  </NOBR> ) const;</TD></TR>
</TABLE>

<P>Virtual form of <A HREF="GHOST_c_gstTriPolyMeshcpup.html#f_gstTriPolyMesh_staticIsOfType_int">staticIsOfType</A>.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_polygonsBegin_const"></A>polygonsBegin</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>gstTriPolyPtrHashMapConstIterator <B>polygonsBegin</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) const;</TD></TR>
</TABLE>

<P>Returns an iterater pointing to the begining of the polygons defined for this <A HREF="GHOST_c_gstTriPolyMesh_c.html#c_gstTriPolyMesh">gstTriPolyMesh</A>.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_polygonsEnd_const"></A>polygonsEnd</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>gstTriPolyPtrHashMapConstIterator <B>polygonsEnd</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) const;</TD></TR>
</TABLE>

<P>Returns an iterater pointing to the end of the polygons defined for this <A HREF="GHOST_c_gstTriPolyMesh_c.html#c_gstTriPolyMesh">gstTriPolyMesh</A>.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_removePolygon_const_int"></A>removePolygon</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>gstBoolean <B>removePolygon</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>const gstPolyKey polyKey  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Removes <A HREF="GHOST_c_gstTriPoly_c.html#c_gstTriPoly">gstTriPoly</A> defined for this mesh with key equal to polyKey and returns TRUE if one exists that meets this criteria. Otherwise, FALSE is returned.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_removePolygon_gstTriPolyPtrPtr"></A>removePolygon</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>gstBoolean <B>removePolygon</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR><A HREF="GHOST_c_gstTriPoly_c.html#c_gstTriPoly">gstTriPoly</A>** polyToRemove  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Removes <A HREF="GHOST_c_gstTriPoly_c.html#c_gstTriPoly">gstTriPoly</A> polyToRemove if it is contained by this mesh and returns TRUE. Otherwise, FALSE is returned.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_removeVertex_const_int"></A>removeVertex</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>gstBoolean <B>removeVertex</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>const gstVertexKey vertKey  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Removes <A HREF="GHOST_c_gstVertex_c.html#c_gstVertex">gstVertex</A> defined for this mesh with key equal to vertKey and returns TRUE if one exists that meets this criteria. Otherwise, FALSE is returned.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_setDeleteStrandedVertices_const_int"></A>setDeleteStrandedVertices</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>void <B>setDeleteStrandedVertices</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>const gstBoolean deleteStrandedVertices  </NOBR> ) ;</TD></TR>
</TABLE>

<P>If deleteStrandedVertices is TRUE, vertices that have no neighbor edges are to be deleted. Otherwise, they are left alone.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_setSpatialPartition_gstSpatialPartitionPtr"></A>setSpatialPartition</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>void <B>setSpatialPartition</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR><A HREF="GHOST_c_gstSpatialPartition_c.html#c_gstSpatialPartition">gstSpatialPartition</A>* s  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Sets spatial partition defined for this object to s.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_setUseSpatialPartition_int"></A>setUseSpatialPartition</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>void <B>setUseSpatialPartition</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>gstBoolean u  </NOBR> ) ;</TD></TR>
</TABLE>

<P>If u is TRUE the spatial partition defined for this mesh is used to speed up calculations if one exists. Otherwise, all polygons are examined for calculations requiring it.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_useSpatialPartition_const"></A>useSpatialPartition</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>gstBoolean <B>useSpatialPartition</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) const;</TD></TR>
</TABLE>

<P>Returns TRUE if the spatial partition defined for this mesh is used to speed up calculations if one has been created. Otherwise FALSE is returned meaning all polygons are examined for calculations requiring it.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_verticesBegin_const"></A>verticesBegin</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>gstVertexPtrHashMapConstIterator <B>verticesBegin</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) const;</TD></TR>
</TABLE>

<P>Returns begining iterator for vertices.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_verticesEnd_const"></A>verticesEnd</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>gstVertexPtrHashMapConstIterator <B>verticesEnd</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) const;</TD></TR>
</TABLE>

<P>Returns ending iterator for vertices.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_getClassTypeId"></A>getClassTypeId</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>static gstType <B>getClassTypeId</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) ;</TD></TR>
</TABLE>

<P>Static: get type id of this class.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPolyMesh_staticIsOfType_int"></A>staticIsOfType</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>static gstBoolean <B>staticIsOfType</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>gstType type  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Return TRUE if class is of the given type or is derived from that type.






</BODY>
</HTML>

