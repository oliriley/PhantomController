<HTML>
<HEAD>
<TITLE>Public Members for ghostGLManager</TITLE>
<!-- BBSOO Generated by Object Outline 2.1d, Bumble Bee Software April 29, 2002 -->
<LINK REL=STYLESHEET HREF="main.css">
</HEAD>

<BODY  TOPMARGIN=0>

<SPAN>
<TABLE WIDTH="100%" CELLPADDING=5 BGCOLOR=black CELLSPACING=0>
<TR ALIGN=LEFT><TD class="HEADER">
    <A HREF="GHOST_c_ghostGLManager_c.html#c_ghostGLManager" STYLE="background: black;color: white;text-decoration: none;">Overview For ghostGLManager</A>
    <IMG BORDER=0 SRC="sep.gif"><A HREF="GHOST_c_ghostGLManager_c.html#ud43525029c_ghostGLManager_classtoc" STYLE="background : black;color: white;text-decoration: none;">Members</A>
    <IMG BORDER=0 SRC="sep.gif"><A HREF="GHOST_II___GHOST_GL_library_ch.html#chp_GHOST_SDK_Reference_Manual_II___GHOST_GL_library" STYLE="background: black;color: white;text-decoration: none;">Chapter </A>
</TD></TR></TABLE>
</SPAN>



<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_ghostGLManager_ghostGLManager_ghostGLCameraBasePtr"></A>ghostGLManager</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR> <B>ghostGLManager</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR><A HREF="GHOST_c_ghostGLCameraBase_c.html#c_ghostGLCameraBase">ghostGLCameraBase</A>* camera  = NULL </NOBR> ) ;</TD></TR>
</TABLE>

<P>Sets up the camera and initializes OpenGL state for the rendering context.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_ghostGLManager__ghostGLManager"></A>~ghostGLManager</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>virtual <B>~ghostGLManager</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) ;</TD></TR>
</TABLE>

<P>Cleans up the objects belonging to this <A HREF="GHOST_c_ghostGLManagercpup.html#f_ghostGLManager_ghostGLManager_ghostGLCameraBasePtr">ghostGLManager</A> instance.<P CLASS=OOCMT>Note : If you created your own camera, you'll need to delete it yourself.</P>







<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_ghostGLManager_addActionObject_ghostGLActionObjectPtr"></A>addActionObject</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>virtual void <B>addActionObject</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR><A HREF="GHOST_c_ghostGLActionObject_c.html#c_ghostGLActionObject">ghostGLActionObject</A>* obj  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Adds an action object to be pinged every <A HREF="GHOST_c_ghostGLManagercpup.html#f_ghostGLManager_redraw">redraw</A>. This allows you to have dynamic operations occuring at the graphics rate.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_ghostGLManager_clearAll"></A>clearAll</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>void <B>clearAll</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) ;</TD></TR>
</TABLE>

<P>Cleanup methods that remove the <A HREF="GHOST_c_gfxDisplaySettings_c.html#c_gfxDisplaySettings">gfxDisplaySettings</A> and callback related data.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_ghostGLManager_clearNode_gstTransformPtr"></A>clearNode</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>void <B>clearNode</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR><A HREF="GHOST_c_gstTransform_c.html#c_gstTransform">gstTransform</A>* node  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Frees the display lists and other GhostGL data associated with this node.<P CLASS=OOCMT>Note : If you have your own user-defined callback and data, clearing the node will still preserve your callback and data.</P>







<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_ghostGLManager_clearSeparator_gstSeparatorPtr"></A>clearSeparator</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>void <B>clearSeparator</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR><A HREF="GHOST_c_gstSeparator_c.html#c_gstSeparator">gstSeparator</A>* sep  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Calls <A HREF="GHOST_c_ghostGLManagercpup.html#f_ghostGLManager_clearNode_gstTransformPtr">clearNode</A>() on all descendents of the separator.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_ghostGLManager_getCamera_const"></A>getCamera</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR><A HREF="GHOST_c_ghostGLCameraBase_c.html#c_ghostGLCameraBase">ghostGLCameraBase</A>* <B>getCamera</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) const;</TD></TR>
</TABLE>

<P>






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_ghostGLManager_getDisplaySettings_gstTransformPtr"></A>getDisplaySettings</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR><A HREF="GHOST_c_gfxDisplaySettings_c.html#c_gfxDisplaySettings">gfxDisplaySettings</A>* <B>getDisplaySettings</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR><A HREF="GHOST_c_gstTransform_c.html#c_gstTransform">gstTransform</A>* node  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Returns the <A HREF="GHOST_c_gfxDisplaySettings_c.html#c_gfxDisplaySettings">gfxDisplaySettings</A> instance for a particular node.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_ghostGLManager_getPhantomCumulativeTransform_const"></A>getPhantomCumulativeTransform</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR><A HREF="GHOST_c_gstTransformMatrix_c.html#c_gstTransformMatrix">gstTransformMatrix</A> <B>getPhantomCumulativeTransform</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) const;</TD></TR>
</TABLE>

<P>






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_ghostGLManager_getPhantomDisplaySettings_gstPHANToMPtr"></A>getPhantomDisplaySettings</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR><A HREF="GHOST_c_gfxPhantomDisplaySettings_c.html#c_gfxPhantomDisplaySettings">gfxPhantomDisplaySettings</A>* <B>getPhantomDisplaySettings</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR><A HREF="GHOST_c_gstPHANToM_c.html#c_gstPHANToM">gstPHANToM</A>* phantom  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Returns the <A HREF="GHOST_c_gfxPhantomDisplaySettings_c.html#c_gfxPhantomDisplaySettings">gfxPhantomDisplaySettings</A> node for a <A HREF="GHOST_c_gstPHANToM_c.html#c_gstPHANToM">gstPHANToM</A> node.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_ghostGLManager_getPhantomNode_const"></A>getPhantomNode</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR><A HREF="GHOST_c_gstPHANToM_c.html#c_gstPHANToM">gstPHANToM</A>* <B>getPhantomNode</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) const;</TD></TR>
</TABLE>

<P>Returns the first PHANToM instance in the pool of current PHANToMs.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_ghostGLManager_getPhantomTransform_const"></A>getPhantomTransform</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR><A HREF="GHOST_c_gstTransformMatrix_c.html#c_gstTransformMatrix">gstTransformMatrix</A> <B>getPhantomTransform</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) const;</TD></TR>
</TABLE>

<P>Get data about the PHANToM from the last graphics callback.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_ghostGLManager_getScene"></A>getScene</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR><A HREF="GHOST_c_gstScene_c.html#c_gstScene">gstScene</A>* <B>getScene</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) ;</TD></TR>
</TABLE>

<P>






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_ghostGLManager_getUserData_gstTransformPtr"></A>getUserData</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>void* <B>getUserData</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR><A HREF="GHOST_c_gstTransform_c.html#c_gstTransform">gstTransform</A>* node  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Returns a previously set userdata element.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_ghostGLManager_isAxesOn_const"></A>isAxesOn</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>gstBoolean <B>isAxesOn</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) const;</TD></TR>
</TABLE>

<P>






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_ghostGLManager_isGraphicsOn_const"></A>isGraphicsOn</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>gstBoolean <B>isGraphicsOn</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) const;</TD></TR>
</TABLE>

<P>






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_ghostGLManager_loadScene_gstScenePtr"></A>loadScene</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>virtual void <B>loadScene</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR><A HREF="GHOST_c_gstScene_c.html#c_gstScene">gstScene</A>* scene  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Handles setting up the <A HREF="GHOST_c_gstScene_c.html#c_gstScene">gstScene</A> instance for GhostGL rendering. Each node in the scene needs to be setup with a graphics callback and a <A HREF="GHOST_c_gfxDisplaySettings_c.html#c_gfxDisplaySettings">gfxDisplaySettings</A> structure.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_ghostGLManager_redraw"></A>redraw</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>virtual void <B>redraw</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) ;</TD></TR>
</TABLE>

<P>The main entry point for having ghostGL draw the scene. It handles calling all of the action objects, applying the current camera transform and the uses <A HREF="GHOST_c_ghostGLManagercpro.html#f_ghostGLManager_drawScene">drawScene</A>() to render all of the nodes.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_ghostGLManager_removeActionObject_ghostGLActionObjectPtr"></A>removeActionObject</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>virtual void <B>removeActionObject</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR><A HREF="GHOST_c_ghostGLActionObject_c.html#c_ghostGLActionObject">ghostGLActionObject</A>* obj  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Removes the specified action object instance from the list of action objects.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_ghostGLManager_reshape_int_int"></A>reshape</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>virtual void <B>reshape</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>int width  ,</NOBR> <NOBR>int height  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Reshape should be called with the current view dimensions everytime the rendering context is resized.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_ghostGLManager_setAxesOn_int"></A>setAxesOn</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>void <B>setAxesOn</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>gstBoolean bEnable  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Accessor methods for turning on/off the coordinate origin.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_ghostGLManager_setCamera_ghostGLCameraBasePtr"></A>setCamera</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>virtual void <B>setCamera</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR><A HREF="GHOST_c_ghostGLCameraBase_c.html#c_ghostGLCameraBase">ghostGLCameraBase</A>* camera  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Specify your own camera for viewing the scene.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_ghostGLManager_setGeometryLock_gstTransformPtr_int"></A>setGeometryLock</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>void <B>setGeometryLock</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR><A HREF="GHOST_c_gstTransform_c.html#c_gstTransform">gstTransform</A>* node  ,</NOBR> <NOBR>gstBoolean bLock  </NOBR> ) ;</TD></TR>
</TABLE>

<P>If you know that a nonstatic node is not going to be changing its geometry frequently, you can lock the geometry and get better rendering performance.<P CLASS=OOCMT>This routine will work recursively off of a separator, or you can just perform this on an individual node.</P>







<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_ghostGLManager_setGraphicsCallback_gstTransformPtr_gstGraphicsCallbackPtr_voidPtr"></A>setGraphicsCallback</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>void <B>setGraphicsCallback</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR><A HREF="GHOST_c_gstTransform_c.html#c_gstTransform">gstTransform</A>* node  ,</NOBR> <NOBR>gstGraphicsCallback* callback  ,</NOBR> <NOBR>void* userdata  = NULL </NOBR> ) ;</TD></TR>
</TABLE>

<P>Since <A HREF="GHOST_c_ghostGLManagercpup.html#f_ghostGLManager_ghostGLManager_ghostGLCameraBasePtr">ghostGLManager</A> uses GHOST's own graphics callback fields to store information, it provides its own callback/userdata field. This method sets a callback and userdata pair for a given node. The graphics callback will be called from <A HREF="GHOST_c_ghostGLManagercpup.html#f_ghostGLManager_ghostGLManager_ghostGLCameraBasePtr">ghostGLManager</A>'s own graphics callback. NULL for either argument will set that field to NULL. There is no &quot;keep previous&quot; if you only want to change one argument.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_ghostGLManager_setGraphicsOn_int"></A>setGraphicsOn</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>void <B>setGraphicsOn</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>gstBoolean bEnable  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Accessor methods for enabling/disabling drawing.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_ghostGLManager_setTouchableByPHANToM_int"></A>setTouchableByPHANToM</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>void <B>setTouchableByPHANToM</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>gstBoolean bTouchable  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Change properties about the scene in a local or global manner.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_ghostGLManager_setVisible_gstTransformPtr_int"></A>setVisible</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>void <B>setVisible</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR><A HREF="GHOST_c_gstTransform_c.html#c_gstTransform">gstTransform</A>* node  ,</NOBR> <NOBR>gstBoolean bVisible  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Allows you to recursively specify visiblity for one or several nodes. If a separator node is passed in, all of its descendants will be affected. When a node is made invisible, all of its display list entries are deleted. When the node is made visible again, it will automatically be setup again for rendering.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_ghostGLManager_updateNode_gstTransformPtr_voidPtr_voidPtr"></A>updateNode</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>static void <B>updateNode</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR><A HREF="GHOST_c_gstTransform_c.html#c_gstTransform">gstTransform</A>* node  ,</NOBR> <NOBR>void* cbData  ,</NOBR> <NOBR>void* userData  </NOBR> ) ;</TD></TR>
</TABLE>

<P>This is the graphics callback routine used for all nodes except the PHANToM.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_ghostGLManager_updatePhantom_gstTransformPtr_voidPtr_voidPtr"></A>updatePhantom</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>static void <B>updatePhantom</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR><A HREF="GHOST_c_gstTransform_c.html#c_gstTransform">gstTransform</A>* node  ,</NOBR> <NOBR>void* cbData  ,</NOBR> <NOBR>void* userData  </NOBR> ) ;</TD></TR>
</TABLE>

<P>This is the graphics callback routine used for just PHANToM nodes.






</BODY>
</HTML>

