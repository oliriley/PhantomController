<HTML>
<HEAD>
<TITLE>Public Members for gstScene</TITLE>
<!-- BBSOO Generated by Object Outline 2.1d, Bumble Bee Software April 29, 2002 -->
<LINK REL=STYLESHEET HREF="main.css">
</HEAD>

<BODY  TOPMARGIN=0>

<SPAN>
<TABLE WIDTH="100%" CELLPADDING=5 BGCOLOR=black CELLSPACING=0>
<TR ALIGN=LEFT><TD class="HEADER">
    <A HREF="GHOST_c_gstScene_c.html#c_gstScene" STYLE="background: black;color: white;text-decoration: none;">Overview For gstScene</A>
    <IMG BORDER=0 SRC="sep.gif"><A HREF="GHOST_c_gstScene_c.html#ud43525029c_gstScene_classtoc" STYLE="background : black;color: white;text-decoration: none;">Members</A>
    <IMG BORDER=0 SRC="sep.gif"><A HREF="GHOST_I___GHOST_Library_1__Core_Classes_ch.html#chp_GHOST_SDK_Reference_Manual_I___GHOST_Library_1__Core_Classes" STYLE="background: black;color: white;text-decoration: none;">Chapter </A>
</TD></TR></TABLE>
</SPAN>



<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstScene_gstScene"></A>gstScene</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR> <B>gstScene</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) ;</TD></TR>
</TABLE>

<P>Constructor.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstScene__gstScene"></A>~gstScene</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR> <B>~gstScene</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) ;</TD></TR>
</TABLE>

<P>Performs a recursive delete on all nodes under the root.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstScene_cleanupServoLoop"></A>cleanupServoLoop</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>void <B>cleanupServoLoop</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) ;</TD></TR>
</TABLE>

<P>Clean up the haptic simulation after an internal error.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstScene_getDoneOneLoop_const"></A>getDoneOneLoop</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>int <B>getDoneOneLoop</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) const;</TD></TR>
</TABLE>

<P>For internal use.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstScene_getDoneServoLoop_const"></A>getDoneServoLoop</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>int <B>getDoneServoLoop</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) const;</TD></TR>
</TABLE>

<P>Returns TRUE if haptics process has finished (i.e. If the servo loop is not running).






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstScene_getRoot"></A>getRoot</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR><A HREF="GHOST_c_gstTransform_c.html#c_gstTransform">gstTransform</A>* <B>getRoot</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) ;</TD></TR>
</TABLE>

<P>






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstScene_getRoot_const"></A>getRoot</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>const <A HREF="GHOST_c_gstTransform_c.html#c_gstTransform">gstTransform</A>* <B>getRoot</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) const;</TD></TR>
</TABLE>

<P>Get root node of haptic scene graph.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstScene_getSafety_const"></A>getSafety</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>gstBoolean <B>getSafety</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) const;</TD></TR>
</TABLE>

<P>Returns TRUE if safety limits are on.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstScene_getSafetyLimit_const"></A>getSafetyLimit</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>double <B>getSafetyLimit</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) const;</TD></TR>
</TABLE>

<P>Returns the currently set duty cycle limit (sec).






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstScene_getSmoothing_const"></A>getSmoothing</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>int <B>getSmoothing</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) const;</TD></TR>
</TABLE>

<P>Get smoothing level of the scene.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstScene_lock"></A>lock</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>gstBoolean <B>lock</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) ;</TD></TR>
</TABLE>

<P>Lock() a <A HREF="GHOST_c_gstScenecpup.html#f_gstScene_gstScene">gstScene</A> before making changes to it if the servo loop is running. NOTE: Changes to the phantom or its ancestor nodes are not supported when the servo loop is running, even if the scene is locked. Also, effects and manipulators will still be run even if the scene is locked, so if this is incompatible with the changes being made they should be stopped before making changes. Finally, force fields are not enabled when the scene is locked. Returns TRUE if <A HREF="GHOST_c_gstScenecpup.html#f_gstScene_lock">lock</A> acquired, FALSE otherwise (if servo loop stopped).






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstScene_postServoLoop"></A>postServoLoop</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>int <B>postServoLoop</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) ;</TD></TR>
</TABLE>

<P>






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstScene_preServoLoop"></A>preServoLoop</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>int <B>preServoLoop</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) ;</TD></TR>
</TABLE>

<P>






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstScene_servoLoop"></A>servoLoop</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>int <B>servoLoop</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) ;</TD></TR>
</TABLE>

<P>For internal use.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstScene_setDoneOneLoop_int"></A>setDoneOneLoop</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>void <B>setDoneOneLoop</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>gstBoolean newVal  </NOBR> ) ;</TD></TR>
</TABLE>

<P>For internal use.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstScene_setPostServoCallback_gstServoCallbackPtr_voidPtr"></A>setPostServoCallback</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>void <B>setPostServoCallback</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>gstServoCallback* pCallback  ,</NOBR> <NOBR>void* pUserData  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Provide a callback to be called in the servoloop thread following the last servoloop tick.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstScene_setPreServoCallback_gstServoCallbackPtr_voidPtr"></A>setPreServoCallback</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>void <B>setPreServoCallback</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>gstServoCallback* pCallback  ,</NOBR> <NOBR>void* pUserData  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Provide a callback to be called in the servoloop thread before the first servoloop tick.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstScene_setRoot_gstTransformPtr"></A>setRoot</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>void <B>setRoot</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR><A HREF="GHOST_c_gstTransform_c.html#c_gstTransform">gstTransform</A>* newRoot  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Set root node of haptic scene graph.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstScene_setSafety_int"></A>setSafety</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>void <B>setSafety</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>gstBoolean _s  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Turns safety on and off. If safety is off, the servo loop is allowed to take as much CPU time as necessary to finish. This may result in instability or crashes. The default is TRUE (on).






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstScene_setSafetyLimit_double"></A>setSafetyLimit</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>void <B>setSafetyLimit</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>double limit  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Sets the duty cycle limit in seconds that gets checked by the safety.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstScene_setServoCallback_gstServoCallbackPtr_voidPtr"></A>setServoCallback</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>void <B>setServoCallback</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>gstServoCallback* pCallback  ,</NOBR> <NOBR>void* pUserData  </NOBR> ) ;</TD></TR>
</TABLE>

<P>In addition to the standard Ghost servoloop activity, you can hook in your own callback function that will get called at servo rate.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstScene_setSmoothing_int"></A>setSmoothing</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>void <B>setSmoothing</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>int newLevel  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Set smoothing level for scene. Smoothing attempts to remove high-frequency variations in gstPolyMesh geometries. Currently only 0 (OFF) and 1 (ON) are supported.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstScene_startServoLoop"></A>startServoLoop</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>int <B>startServoLoop</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) ;</TD></TR>
</TABLE>

<P>Start the haptic simulation as separate process. Control is returned immediately.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstScene_stopServoLoop"></A>stopServoLoop</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>void <B>stopServoLoop</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) ;</TD></TR>
</TABLE>

<P>Stop the haptic simulation.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstScene_turnForcesOff"></A>turnForcesOff</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>void <B>turnForcesOff</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) ;</TD></TR>
</TABLE>

<P>For internal use.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstScene_turnForcesOn"></A>turnForcesOn</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>void <B>turnForcesOn</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) ;</TD></TR>
</TABLE>

<P>For internal use.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstScene_unlock"></A>unlock</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>void <B>unlock</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) ;</TD></TR>
</TABLE>

<P>Call <A HREF="GHOST_c_gstScenecpup.html#f_gstScene_unlock">unlock</A>() after a <A HREF="GHOST_c_gstScenecpup.html#f_gstScene_lock">lock</A>() to resume normal servo loop behavior. NOTE: the scene should remain locked for only a few servo loop iterations (each iteration is 1ms) to maintain an accurate haptic simulation.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstScene_updateEvents"></A>updateEvents</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>void <B>updateEvents</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) ;</TD></TR>
</TABLE>

<P>Calls the event callback for all nodes in the scene which have new events since the last call to <A HREF="GHOST_c_gstScenecpup.html#f_gstScene_updateEvents">updateEvents</A>(). Each callback is called once for each new event.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstScene_updateGraphics"></A>updateGraphics</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>void <B>updateGraphics</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) ;</TD></TR>
</TABLE>

<P>Calls the graphics callbacks for all nodes in the scene which have changed since the last call to <A HREF="GHOST_c_gstScenecpup.html#f_gstScene_updateGraphics">updateGraphics</A>(). This means nodes which have not changed will not have their graphics callback called.






</BODY>
</HTML>

