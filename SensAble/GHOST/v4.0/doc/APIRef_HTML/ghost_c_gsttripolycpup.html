<HTML>
<HEAD>
<TITLE>Public Members for gstTriPoly</TITLE>
<!-- BBSOO Generated by Object Outline 2.1d, Bumble Bee Software April 29, 2002 -->
<LINK REL=STYLESHEET HREF="main.css">
</HEAD>

<BODY  TOPMARGIN=0>

<SPAN>
<TABLE WIDTH="100%" CELLPADDING=5 BGCOLOR=black CELLSPACING=0>
<TR ALIGN=LEFT><TD class="HEADER">
    <A HREF="GHOST_c_gstTriPoly_c.html#c_gstTriPoly" STYLE="background: black;color: white;text-decoration: none;">Overview For gstTriPoly</A>
    <IMG BORDER=0 SRC="sep.gif"><A HREF="GHOST_c_gstTriPoly_c.html#ud43525029c_gstTriPoly_classtoc" STYLE="background : black;color: white;text-decoration: none;">Members</A>
    <IMG BORDER=0 SRC="sep.gif"><A HREF="GHOST_I___GHOST_Library_7__Polygon_Mesh_ch.html#chp_GHOST_SDK_Reference_Manual_I___GHOST_Library_7__Polygon_Mesh" STYLE="background: black;color: white;text-decoration: none;">Chapter </A>
</TD></TR></TABLE>
</SPAN>



<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPoly_gstTriPoly_gstVertexPtr_gstVertexPtr_gstVertexPtr_gstTriPolyMeshBasePtr_const_int"></A>gstTriPoly</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR> <B>gstTriPoly</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR><A HREF="GHOST_c_gstVertex_c.html#c_gstVertex">gstVertex</A>* _v1  ,</NOBR> <NOBR><A HREF="GHOST_c_gstVertex_c.html#c_gstVertex">gstVertex</A>* _v2  ,</NOBR> <NOBR><A HREF="GHOST_c_gstVertex_c.html#c_gstVertex">gstVertex</A>* _v3  ,</NOBR> <NOBR><A HREF="GHOST_c_gstTriPolyMeshBase_c.html#c_gstTriPolyMeshBase">gstTriPolyMeshBase</A>* mesh  = NULL ,</NOBR> <NOBR>const gstPolyKey _key  = NULL </NOBR> ) ;</TD></TR>
</TABLE>

<P>Creates Triangle defined by the 3 vertices v1, v2, and v3. V1, v2, and v3 are assumed not to be all colinear and should all be distinct objects. The triangle will have undefined behavior otherwise.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPoly__gstTriPoly"></A>~gstTriPoly</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>virtual <B>~gstTriPoly</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) ;</TD></TR>
</TABLE>

<P>






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPoly_beginModify"></A>beginModify</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>gstBoolean <B>beginModify</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) ;</TD></TR>
</TABLE>

<P>Called when 'this' <A HREF="GHOST_c_gstTriPolycpup.html#f_gstTriPoly_gstTriPoly_gstVertexPtr_gstVertexPtr_gstVertexPtr_gstTriPolyMeshBasePtr_const_int">gstTriPoly</A> object is going to be modified.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPoly_clone_const"></A>clone</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>virtual <A HREF="GHOST_c_gstSpatialObject_c.html#c_gstSpatialObject">gstSpatialObject</A>* <B>clone</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) const;</TD></TR>
</TABLE>

<P>Virtual method to copy this object and return base class pointer to newly copied object. Allows copy of object to be made using base class pointer.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPoly_cloneTriPoly_const"></A>cloneTriPoly</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR><A HREF="GHOST_c_gstTriPolycpup.html#f_gstTriPoly_gstTriPoly_gstVertexPtr_gstVertexPtr_gstVertexPtr_gstTriPolyMeshBasePtr_const_int">gstTriPoly</A>* <B>cloneTriPoly</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) const;</TD></TR>
</TABLE>

<P>Virtual method to copy this <A HREF="GHOST_c_gstTriPolycpup.html#f_gstTriPoly_gstTriPoly_gstVertexPtr_gstVertexPtr_gstVertexPtr_gstTriPolyMeshBasePtr_const_int">gstTriPoly</A> object and return <A HREF="GHOST_c_gstTriPolycpup.html#f_gstTriPoly_gstTriPoly_gstVertexPtr_gstVertexPtr_gstVertexPtr_gstTriPolyMeshBasePtr_const_int">gstTriPoly</A> pointer to newly cloned object.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPoly_convertToBarycentricCoord_const_gstPointRef_const"></A>convertToBarycentricCoord</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR><A HREF="GHOST_c_gstPoint_c.html#c_gstPoint">gstPoint</A> <B>convertToBarycentricCoord</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>const <A HREF="GHOST_c_gstPoint_c.html#c_gstPoint">gstPoint</A>&amp; pt  </NOBR> ) const;</TD></TR>
</TABLE>

<P>Given a 3D point coplaner with this triangle, the corresponding barycentric coordinate is returned. The returned barycentric coordinate is only valid if pt is coplaner and within the boundary of the triangle. Otherwise, the result is undefined.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPoly_convertToCartesianCoord_const_gstPoint2DRef_const"></A>convertToCartesianCoord</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR><A HREF="GHOST_c_gstPoint_c.html#c_gstPoint">gstPoint</A> <B>convertToCartesianCoord</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>const <A HREF="GHOST_c_gstPoint2D_c.html#c_gstPoint2D">gstPoint2D</A>&amp; uvCoord  </NOBR> ) const;</TD></TR>
</TABLE>

<P>Convert UV coordinate to 3D point.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPoly_convertToUVCoord_const_gstPointRef_const"></A>convertToUVCoord</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR><A HREF="GHOST_c_gstPoint2D_c.html#c_gstPoint2D">gstPoint2D</A> <B>convertToUVCoord</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>const <A HREF="GHOST_c_gstPoint_c.html#c_gstPoint">gstPoint</A>&amp; pt  </NOBR> ) const;</TD></TR>
</TABLE>

<P>Converts 3D point coplaner with triangle to UV coordinates of triangle. U is along v1-&gt;v2 vector and V is along v1-&gt;v3 vector. Undefined results for points not coplaner with the triangle.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPoly_e1_const"></A>e1</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR><A HREF="GHOST_c_gstEdge_c.html#c_gstEdge">gstEdge</A>* <B>e1</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) const;</TD></TR>
</TABLE>

<P>Returns pointer to edge1 (v1-&gt;v2).






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPoly_e2_const"></A>e2</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR><A HREF="GHOST_c_gstEdge_c.html#c_gstEdge">gstEdge</A>* <B>e2</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) const;</TD></TR>
</TABLE>

<P>Returns pointer to edge2 (v2-&gt;v3).






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPoly_e3_const"></A>e3</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR><A HREF="GHOST_c_gstEdge_c.html#c_gstEdge">gstEdge</A>* <B>e3</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) const;</TD></TR>
</TABLE>

<P>Returns pointer to edge3 (v3-&gt;v1).






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPoly_endModify"></A>endModify</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>gstBoolean <B>endModify</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) ;</TD></TR>
</TABLE>

<P>Called when 'this' <A HREF="GHOST_c_gstTriPolycpup.html#f_gstTriPoly_gstTriPoly_gstVertexPtr_gstVertexPtr_gstVertexPtr_gstTriPolyMeshBasePtr_const_int">gstTriPoly</A> object is done being modified.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPoly_getBoundingBox"></A>getBoundingBox</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>virtual <A HREF="GHOST_c_gstBoundingBox_c.html#c_gstBoundingBox">gstBoundingBox</A> <B>getBoundingBox</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) ;</TD></TR>
</TABLE>

<P>Returns <A HREF="GHOST_c_gstBoundingBox_c.html#c_gstBoundingBox">gstBoundingBox</A> just enclosing this triangle.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPoly_getE1_const"></A>getE1</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR><A HREF="GHOST_c_gstEdge_c.html#c_gstEdge">gstEdge</A>* <B>getE1</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) const;</TD></TR>
</TABLE>

<P>Returns pointer to edge1 (v1-&gt;v2).






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPoly_getE2_const"></A>getE2</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR><A HREF="GHOST_c_gstEdge_c.html#c_gstEdge">gstEdge</A>* <B>getE2</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) const;</TD></TR>
</TABLE>

<P>Returns pointer to edge2 (v2-&gt;v3).






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPoly_getE3_const"></A>getE3</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR><A HREF="GHOST_c_gstEdge_c.html#c_gstEdge">gstEdge</A>* <B>getE3</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) const;</TD></TR>
</TABLE>

<P>Returns pointer to edge3 (v3-&gt;v1).






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPoly_getKey_const"></A>getKey</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>gstPolyKey <B>getKey</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) const;</TD></TR>
</TABLE>

<P>Returns unique id of this object. This id is created at object construction.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPoly_getPoly_unsigned_int"></A>getPoly</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR><A HREF="GHOST_c_gstTriPolycpup.html#f_gstTriPoly_gstTriPoly_gstVertexPtr_gstVertexPtr_gstVertexPtr_gstTriPolyMeshBasePtr_const_int">gstTriPoly</A>* <B>getPoly</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>unsigned int index  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Returns pointer to <A HREF="GHOST_c_gstTriPolycpup.html#f_gstTriPoly_gstTriPoly_gstVertexPtr_gstVertexPtr_gstVertexPtr_gstTriPolyMeshBasePtr_const_int">gstTriPoly</A> cooresponding to correct index. Index '0' refers to this poly. Indices '1', '2', and '3' refer to the tri poly on the opposite side of edge1, edge2, or edge3 respectively. If no poly exists for the given index NULL is returned.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPoly_getPropertyContainer"></A>getPropertyContainer</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR><A HREF="GHOST_c_gstPolyPropertyContainer_c.html#c_gstPolyPropertyContainer">gstPolyPropertyContainer</A>&amp; <B>getPropertyContainer</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) ;</TD></TR>
</TABLE>

<P>Returns pointer to <A HREF="GHOST_c_gstPolyPropertyContainer_c.html#c_gstPolyPropertyContainer">gstPolyPropertyContainer</A> class storing polygonal property information (ie. Vertex normals...) pertaining to this <A HREF="GHOST_c_gstTriPolycpup.html#f_gstTriPoly_gstTriPoly_gstVertexPtr_gstVertexPtr_gstVertexPtr_gstTriPolyMeshBasePtr_const_int">gstTriPoly</A>.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPoly_getTriPolyMesh_const"></A>getTriPolyMesh</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR><A HREF="GHOST_c_gstTriPolyMeshBase_c.html#c_gstTriPolyMeshBase">gstTriPolyMeshBase</A>* <B>getTriPolyMesh</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) const;</TD></TR>
</TABLE>

<P>Returns pointer to parent <A HREF="GHOST_c_gstTriPolyMesh_c.html#c_gstTriPolyMesh">gstTriPolyMesh</A> object.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPoly_getTypeId_const"></A>getTypeId</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>virtual gstType <B>getTypeId</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) const;</TD></TR>
</TABLE>

<P>Virtual form of <A HREF="GHOST_c_gstTriPolycpup.html#f_gstTriPoly_getClassTypeId">getClassTypeId</A>.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPoly_getV1_const"></A>getV1</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR><A HREF="GHOST_c_gstVertex_c.html#c_gstVertex">gstVertex</A>* <B>getV1</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) const;</TD></TR>
</TABLE>

<P>Returns pointer to v1.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPoly_getV2_const"></A>getV2</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR><A HREF="GHOST_c_gstVertex_c.html#c_gstVertex">gstVertex</A>* <B>getV2</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) const;</TD></TR>
</TABLE>

<P>Returns pointer to v2.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPoly_getV3_const"></A>getV3</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR><A HREF="GHOST_c_gstVertex_c.html#c_gstVertex">gstVertex</A>* <B>getV3</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) const;</TD></TR>
</TABLE>

<P>Returns pointer to v3.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPoly_inside_const_gstPointRef_const"></A>inside</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>gstBoolean <B>inside</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>const <A HREF="GHOST_c_gstPoint_c.html#c_gstPoint">gstPoint</A>&amp; pt  </NOBR> ) const;</TD></TR>
</TABLE>

<P>Returns TRUE if pt is coplaner to this triangle and is within boundary of triangle. If pt is coplaner and outside the boundary of this triangle FALSE is returned. The behavior of this method is undefined if pt is not coplaner with this triangle.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPoly_interpolateNormal_const_gstPointRef"></A>interpolateNormal</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>virtual <A HREF="GHOST_c_gstVector_c.html#c_gstVector">gstVector</A> <B>interpolateNormal</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>const <A HREF="GHOST_c_gstPoint_c.html#c_gstPoint">gstPoint</A>&amp; barycentricCoord  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Returns normal vector of Triangle.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPoly_intersectCoplanar_LS_PE_const_gstLineSegmentRef_gstLineIntersectionInfoFirstTwo_ParamEdgeRef"></A>intersectCoplanar_LS_PE</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>gstBoolean <B>intersectCoplanar_LS_PE</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>const <A HREF="GHOST_c_gstLineSegment_c.html#c_gstLineSegment">gstLineSegment</A>&amp; lineSeg  ,</NOBR> <NOBR><A HREF="GHOST_c_gstLineIntersectionInfoFirstTwo_ParamEdge_c.html#c_gstLineIntersectionInfoFirstTwo_ParamEdge">gstLineIntersectionInfoFirstTwo_ParamEdge</A>&amp; intersectionData  </NOBR> ) ;</TD></TR>
</TABLE>

<P>LineSeg is a line segment co-planer to this <A HREF="GHOST_c_gstTriPolycpup.html#f_gstTriPoly_gstTriPoly_gstVertexPtr_gstVertexPtr_gstVertexPtr_gstTriPolyMeshBasePtr_const_int">gstTriPoly</A> face. The intersection of the line segment may have 0, 1, or 2 intersections along its length with the vertices or edges of the <A HREF="GHOST_c_gstTriPolycpup.html#f_gstTriPoly_gstTriPoly_gstVertexPtr_gstVertexPtr_gstVertexPtr_gstTriPolyMeshBasePtr_const_int">gstTriPoly</A>. TRUE is returned if there are &gt; 0 intersections. Otherwise FALSE is returned. Information about the intersections is stored in intersectionData.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPoly_intersectFirstInOut_LS_P_const_gstLineSegmentRef_gstLineIntersectionInfoFirst_ParamRef"></A>intersectFirstInOut_LS_P</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>virtual <A HREF="GHOST_c_gstLineIntersectionInfo_c.html#c_gstLineIntersectionInfo">gstLineIntersectionInfo</A>::IntersectionType <B>intersectFirstInOut_LS_P</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>const <A HREF="GHOST_c_gstLineSegment_c.html#c_gstLineSegment">gstLineSegment</A>&amp; lineSegment  ,</NOBR> <NOBR><A HREF="GHOST_c_gstLineIntersectionInfoFirst_Param_c.html#c_gstLineIntersectionInfoFirst_Param">gstLineIntersectionInfoFirst_Param</A>&amp; intersectionInfo  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Intersects <A HREF="GHOST_c_gstLineSegment_c.html#c_gstLineSegment">gstLineSegment</A> with spatial object and returns gstIntersection::intersectionType which can be; in, out, inOut, none_inside, or none_outside. 'in' specifies an intersection into the object, 'out' specifies an intersection leaving the object, 'inOut' specifies intersections entering and leaving the object, 'none_insdie' specifies that the object is not intersected and the line segment is within the object, and 'none_outside' specifies that there is no intersection and the line segment is outside of the object.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPoly_intersectFirstIn_LS_P_const_gstLineSegmentRef_gstLineIntersectionInfoFirst_ParamRef"></A>intersectFirstIn_LS_P</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>virtual <A HREF="GHOST_c_gstLineIntersectionInfo_c.html#c_gstLineIntersectionInfo">gstLineIntersectionInfo</A>::IntersectionType <B>intersectFirstIn_LS_P</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>const <A HREF="GHOST_c_gstLineSegment_c.html#c_gstLineSegment">gstLineSegment</A>&amp; lineSegment  ,</NOBR> <NOBR><A HREF="GHOST_c_gstLineIntersectionInfoFirst_Param_c.html#c_gstLineIntersectionInfoFirst_Param">gstLineIntersectionInfoFirst_Param</A>&amp; intersectionInfo  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Intersects <A HREF="GHOST_c_gstLineSegment_c.html#c_gstLineSegment">gstLineSegment</A> with spatial object and returns gstIntersection::intersectionType which can be; in, out, inOut, none_inside, or none_outside. 'in' specifies an intersection into the object, 'out' specifies an intersection leaving the object, 'inOut' specifies intersections entering and leaving the object, 'none_insdie' specifies that the object is not intersected and the line segment is within the object, and 'none_outside' specifies that there is no intersection and the line segment is outside of the object.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPoly_intersectFirstOut_LS_P_const_gstLineSegmentRef_gstLineIntersectionInfoFirst_ParamRef"></A>intersectFirstOut_LS_P</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>virtual <A HREF="GHOST_c_gstLineIntersectionInfo_c.html#c_gstLineIntersectionInfo">gstLineIntersectionInfo</A>::IntersectionType <B>intersectFirstOut_LS_P</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>const <A HREF="GHOST_c_gstLineSegment_c.html#c_gstLineSegment">gstLineSegment</A>&amp; lineSegment  ,</NOBR> <NOBR><A HREF="GHOST_c_gstLineIntersectionInfoFirst_Param_c.html#c_gstLineIntersectionInfoFirst_Param">gstLineIntersectionInfoFirst_Param</A>&amp; intersectionInfo  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Intersects <A HREF="GHOST_c_gstLineSegment_c.html#c_gstLineSegment">gstLineSegment</A> with spatial object and returns gstIntersection::intersectionType which can be; in, out, inOut, none_inside, or none_outside. 'in' specifies an intersection into the object, 'out' specifies an intersection leaving the object, 'inOut' specifies intersections entering and leaving the object, 'none_insdie' specifies that the object is not intersected and the line segment is within the object, and 'none_outside' specifies that there is no intersection and the line segment is outside of the object.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPoly_intersect_BC_const_gstBoundingCubeRef"></A>intersect_BC</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>virtual <A HREF="GHOST_c_gstObjectIntersectionInfo_c.html#c_gstObjectIntersectionInfo">gstObjectIntersectionInfo</A>::IntersectionType <B>intersect_BC</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>const <A HREF="GHOST_c_gstBoundingCube_c.html#c_gstBoundingCube">gstBoundingCube</A>&amp; cube  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Intersects <A HREF="GHOST_c_gstTriPolycpup.html#f_gstTriPoly_gstTriPoly_gstVertexPtr_gstVertexPtr_gstVertexPtr_gstTriPolyMeshBasePtr_const_int">gstTriPoly</A> with <A HREF="GHOST_c_gstBoundingCube_c.html#c_gstBoundingCube">gstBoundingCube</A> object and returns gstObjectObjectIntersection::intersectionType which can be; RV_OVERLAPPING or RV_NONE. 'RV_OVERLAPPING' specifies that the cube encloses or overlaps the triangle, and 'RV_NONE' specifies that the cube and triangle occupy separate space. This method does not distinguish that the cube completely encloses the triangle.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPoly_intersect_BS_const_gstBoundingSphereRef"></A>intersect_BS</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>virtual <A HREF="GHOST_c_gstObjectIntersectionInfo_c.html#c_gstObjectIntersectionInfo">gstObjectIntersectionInfo</A>::IntersectionType <B>intersect_BS</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>const <A HREF="GHOST_c_gstBoundingSphere_c.html#c_gstBoundingSphere">gstBoundingSphere</A>&amp; sphere  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Intersects <A HREF="GHOST_c_gstTriPolycpup.html#f_gstTriPoly_gstTriPoly_gstVertexPtr_gstVertexPtr_gstVertexPtr_gstTriPolyMeshBasePtr_const_int">gstTriPoly</A> with <A HREF="GHOST_c_gstBoundingCube_c.html#c_gstBoundingCube">gstBoundingCube</A> object and returns gstObjectObjectIntersection::intersectionType which can be; RV_OVERLAPPING or RV_NONE. 'RV_OVERLAPPING' specifies that the cube encloses or overlaps the triangle, and 'RV_NONE' specifies that the cube and triangle occupy separate space. This method does not distinguish that the cube completely encloses the triangle.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPoly_isOfType_int_const"></A>isOfType</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>virtual gstBoolean <B>isOfType</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>gstType type  </NOBR> ) const;</TD></TR>
</TABLE>

<P>Virtual form of <A HREF="GHOST_c_gstTriPolycpup.html#f_gstTriPoly_staticIsOfType_int">staticIsOfType</A>.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPoly_modify"></A>modify</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>void <B>modify</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) ;</TD></TR>
</TABLE>

<P>Called when 'this' <A HREF="GHOST_c_gstTriPolycpup.html#f_gstTriPoly_gstTriPoly_gstVertexPtr_gstVertexPtr_gstVertexPtr_gstTriPolyMeshBasePtr_const_int">gstTriPoly</A> object has been modified.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPoly_getClassTypeId"></A>getClassTypeId</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>static gstType <B>getClassTypeId</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                ) ;</TD></TR>
</TABLE>

<P>Static: get type id of this class.






<HR>
<H2 CLASS="FUNCTION_HEADER"><A name="f_gstTriPoly_staticIsOfType_int"></A>staticIsOfType</a></H2>

<TABLE CELLPADDING=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="top" class=code>
    <NOBR>static gstBoolean <B>staticIsOfType</B>(</NOBR></TD>
    <TD ALIGN="left" class=code>
                <NOBR>gstType type  </NOBR> ) ;</TD></TR>
</TABLE>

<P>Return TRUE if class is of the given type or is derived from that type.






</BODY>
</HTML>

