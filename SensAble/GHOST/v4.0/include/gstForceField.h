//=============================================================================
//   Filename : gstForceField.h
//    Project : GHOST library v3.0
//    Authors : Ted Bardasz, Chris Tarr, Tim Gallagher	
//    Revised : Ted Bardasz
// ----------------------------------------------------------------------------
// Description: Base class for force fields, a way to add forces to the PHANToM
//              within some region
//
// Send your questions, comments or bugs to:
//    support@sensable.com
//    http://www.sensable.com
//
// Copyright (c) 1996-1999 SensAble Technologies, Inc. All rights reserved.
//=============================================================================

#ifndef GST_FORCEFIELD
#define GST_FORCEFIELD

#include <gstDllExport.h>
#include <gstPHANToM.h>
#include <gstBoundedHapticObj.h>

#define GST_FORCE_FIELD_MAX_PHANTOM_STATES 4

// State Array struct.  Holds touched state for
//  up to four separate PHANToMs.
typedef struct _gstForceFieldStateArrayStruct {
	gstPHANToM *phantom;
	int			inContact;
	gstPoint	lastSCP;
	gstVector	lastForce;
	gstVector   exitForce;
	gstVector	lastTorque;
	gstVector	exitTorque;
} gstForceFieldStateArrayStruct;

// The GHOST Force Field Class.
// The class is implemented to allow the developer to prescribe forces to
// the PHANToM when the user is within the associated bounding volume.
// The implementation is based on the developer subclassing this class and 
// overloading the calculateForceFieldForce.
// The forces are integrated with forces generated by the shape objects in 
// the scene.
class GHOST_DLL_IMPORT_EXPORT gstForceField : public gstBoundedHapticObj
{
    GHOST_INHERIT_HEADER(gstForceField, gstBoundedHapticObj);

public:
	enum { TOUCHED, UNTOUCHED };

	// Destructor.
	virtual ~gstForceField();

	// Clone.
	virtual gstNode *Clone() const {return CloneForceField();}
	gstForceField *CloneForceField() const {return (new gstForceField(*this));}

	// Sets the distance that the force field force will be attenuated over as the user
	// moves out of the bounding box containing the force field.
	// If this value is zero, the user will feel a buzz when entering a force field
	// in a direction that is opposed by any component of the force vector
	// A good value is in single digit millimeter value range.
	virtual void setAttenuationDistance(const double dist){
		mAttenuationDist = dist;
	}

	// Get the distance that the force field vector will be attenuated over as the 
	// user moves out of the bounding volume containing the force field.
	double getAttenuationDistance() const {
		return mAttenuationDist;
	}
	
	// Overwrite previous position of node with new position.
	virtual void setPosition(double x,double y,double z);

	// Overwrite previous position of node with new position.
	virtual void setPosition(const gstPoint &newPos);

	// Accumulate translation with previous translation for the separator. 
	virtual void translate(double x, double y, double z);
	
	// Accumulate translation with previous translation for the separator. 
	virtual void translate (const gstPoint &translation);

	// Overwrite previous translation with new translation.
	virtual void setTranslation(double x, double y, double z);

	// Overwrite previous translation with new translation.
	virtual void setTranslation(const gstPoint &translation);

	// Accumulate rotation with previous rotation for the separator.
	virtual void rotate(const gstVector &axis, double rad);

	// Overwrite previous rotation with new rotation.
	virtual void setRotation(const gstVector &axis, double rad);

	// Accumulate scale with previous scale for the separator.
	virtual void scale(double scale);

	// Overwrite previous scale with new scale.
	virtual void setScale(double newScale);

	// Get scale factors along scale orientation axis.
	// If the matrix has not been set explicity, then
	// the scale orientation axis' coincide with the
	// local reference frame axis'.
	virtual void getScaleFactor(gstPoint &newScale) const {
		objTransf.getScaleFactor(newScale);
	}

	// Get scale factors along scale orientation axis.
	// If the matrix has not been set explicity, then
	// the scale orientation axis' coincide with the
	// local reference frame axis'.
	virtual gstPoint getScaleFactor() const {
		gstPoint scaleFactorArg;
		getScaleFactor(scaleFactorArg);
		return scaleFactorArg;
	}

	// GHOST_IGNORE_IN_DOC
	// Internal method used to attenuate the force as the user moves away from the 
	// force field boundary.
	gstVector gstForceField::attenuatedForce(
        gstPHANToM *phantom, gstPoint &PHANToMpos, gstVector &appliedTorque);

	// Method to overload to define the force applied by the PHANToM when the 
	// PHANToM has entered the bounding volume associated with the force field

	// This method will protect current customer's code by allowing it to
	// compile and run in the new scheme where the method is called with
	// two arguments.
	virtual gstVector calculateForceFieldForce(gstPHANToM *PHANToM) {
		if (PHANToM) {}     // To remove compiler warning
		return gstVector(0.0,0.0,0.0);
	}

	virtual gstVector calculateForceFieldForce(gstPHANToM *phantom, gstVector &torques) {
		torques.init(0.0, 0.0, 0.0);
		return calculateForceFieldForce(phantom);
	}



gstInternal public:

	// FOR_GHOST_EXTENSION
	// Used by system or for creating sub-classes only.
	// Called when object is added to the scene graph.
	virtual void		putInSceneGraph();

	// FOR_GHOST_EXTENSION
	// Used by system or for creating sub-classes only.
	// Called when object is removed from the scene graph.
	virtual void		removeFromSceneGraph();

	// GHOST_IGNORE_IN_DOC
	// Internal method used to get the number of force fields currently in the scene.
	static gstForceField *getForceFieldsInScene() {
		return forceFieldsInSceneHead;
	}
	
	// Returns "next" force field in force field scene list.
	gstForceField *getNextForceFieldInScene() {
		return nextForceFieldInScene;
	}

	// FOR_GHOST_EXTENSION
	// Return integer representing the contact state for curPHANToM with
	// this shape node.  0 is assumed to be FALSE and represents no
	// contact between curPHANToM and this shape node.  Otherwise, the
	// value may indicate special information about the contact between
	// curPHANToM this shape node.
	virtual int gstForceField::getStateForPHANToM(
        gstPHANToM *curPHANToM,
        gstPoint &lastSCP,
        gstVector &exitForce,
        gstVector &lastForce,
        gstVector &exitTorque,
        gstVector &lastTorque);

	// FOR_GHOST_EXTENSION
	// Update the contact state between this shape node and curPHANToM.  This
	// stores the state for later retrieval with getStateForPHANToM.
	virtual gstBoolean	gstForceField::updateStateForPHANToM(
		gstPHANToM *curPHANToM, 
		int inContact, 
		const gstPoint &lastSCP, 
		const gstVector &exitForce, 
		const gstVector &lastForce,
		const gstVector &exitTorque,
		const gstVector &lastTorque
		) ;

	// This method is used to attenuate the forces from the force fields
    // to the object forces in the scene
	static gstVector attenuateToObjectForces(
        gstVector &forceFieldForce,
        gstVector &objectForces,
        gstPHANToM *phantom);

    // DEPRECATED: Name changed for consistency
    virtual void setTranslate(double x, double y, double z) {
        setTranslation(x, y, z);
    }

    // DEPRECATED: Name changed for consistency
    virtual void setTranslate (const gstPoint &translation) {
        setTranslation(translation);
    }

    // DEPRECATED: Name changed for consistency
    virtual void setRotate(const gstVector &axis, double rad) {
        setRotation(axis, rad);
    }

protected:

	// This class is intended as a base class only, the constructors
	// are protected so that instances can not be created.
	gstForceField();
	gstForceField(const gstForceField *);
	gstForceField(const gstForceField &);

private:
	double mAttenuationDist;
	double mAttenuationTime;

	// Keep track of the force fields in the scene
	static gstForceField	*forceFieldsInSceneHead;
	gstForceField			*nextForceFieldInScene;

	gstForceFieldStateArrayStruct	*stateArray;

	// FOR_GHOST_INTERNAL:
	// Non-uniform scaling is not yet supported for gstForceFields. These are
	// kept private to prevent applications from attempting to perform non-uniform
	// scaling on objects.
	virtual void setScale(const gstPoint &newScale) {
		gstErrorHandler(GST_INVALID_SCALE, "gstForceField::setScale",newScale);
	}
	
	// FOR_GHOST_INTERNAL:
	// Non-uniform scaling is not yet supported in GHOST. These are
	// kept private to prevent applications from attempting to perform non-uniform
	// scaling on objects.
	virtual void setScale(double x, double y, double z) {
		if (x || y || z) {}     // To remove compiler warning
		gstErrorHandler(GST_INVALID_SCALE, "gstForceField::setScale");
	}
	
	// FOR_GHOST_INTERNAL:
	// Non-uniform scaling is not yet supported in GHOST. These are
	// kept private to prevent applications from attempting to perform non-uniform
	// scaling on objects.
	virtual void scale(double x, double y, double z) {
		if (x || y || z) {}     // To remove compiler warning
		gstErrorHandler(GST_INVALID_SCALE, "gstForceField::setScale");
	}
	
	// FOR_GHOST_INTERNAL:
	// Non-uniform scaling is not yet supported in GHOST. These are
	// kept private to prevent applications from attempting to perform non-uniform
	// scaling on objects.
	virtual void scale(const gstPoint &newScale) {
		gstErrorHandler(GST_INVALID_SCALE, "gstForceField::setScale",
			newScale);
	}

};


inline void	gstForceField::translate (const gstPoint &translation)
{
	invalidateCumTransfAndMakeUntouched();
	gstTransform::translate(translation);
}

inline void	gstForceField::translate (double x, double y, double z)
{
    translate(gstPoint(x,y,z));
}


inline void gstForceField::setTranslation(const gstPoint &translation) 
{
    invalidateCumTransfAndMakeUntouched();
    gstTransform::setTranslation(translation);
}

inline void	gstForceField::setTranslation(double x, double y, double z) 
{
    setTranslation(gstPoint(x, y, z));
}

inline void	gstForceField::setPosition(double x, double y, double z) 
{
    setTranslation(gstPoint(x, y, z));
}

inline void	gstForceField::setPosition(const gstPoint &newPos) 
{
    setTranslation(newPos);
}

inline void	gstForceField::rotate(const gstVector &axis, double rad) 
{
    invalidateCumTransfAndMakeUntouched();
    gstTransform::rotate(axis, rad);
}

inline void	gstForceField::setRotation(const gstVector &axis, double rad) 
{
    invalidateCumTransfAndMakeUntouched();
    gstTransform::setRotation(axis, rad);
}

inline void	gstForceField::scale(double scale) 
{
    invalidateCumTransfAndMakeUntouched();
    objTransf.scale(gstPoint(scale, scale, scale));
}

inline void	gstForceField::setScale(double newScale) 
{
    invalidateCumTransfAndMakeUntouched();
    objTransf.setScale(gstPoint(newScale, newScale, newScale));
}


#endif

